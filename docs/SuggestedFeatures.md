# Vechnost Bot - –ê–Ω–∞–ª–∏–∑ –∫–æ–¥–æ–≤–æ–π –±–∞–∑—ã –∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π

**–î–∞—Ç–∞ –∞–Ω–∞–ª–∏–∑–∞:** 6 –¥–µ–∫–∞–±—Ä—è 2025
**–í–µ—Ä—Å–∏—è –ø—Ä–æ–µ–∫—Ç–∞:** 1.0.0
**–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ –º–æ–¥—É–ª–µ–π:** 38 Python —Ñ–∞–π–ª–æ–≤ + 33 –¥–æ–∫—É–º–µ–Ω—Ç–∞

---

## üìä –û–±—â–∞—è –æ—Ü–µ–Ω–∫–∞ –ø—Ä–æ–µ–∫—Ç–∞

### –°–∏–ª—å–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã ‚úÖ

1. **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞:**
   - ‚úÖ –ß–∏—Å—Ç–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ–º –Ω–∞ —Å–ª–æ–∏ (–ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ, –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞, –¥–æ—Å—Ç—É–ø –∫ –¥–∞–Ω–Ω—ã–º)
   - ‚úÖ Repository Pattern –¥–ª—è –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–∏ —Ä–∞–±–æ—Ç—ã —Å –ë–î
   - ‚úÖ Service Layer Pattern –¥–ª—è –∏–Ω–∫–∞–ø—Å—É–ª—è—Ü–∏–∏ –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∏
   - ‚úÖ Registry Pattern –¥–ª—è –º–∞—Ä—à—Ä—É—Ç–∏–∑–∞—Ü–∏–∏ callback-–∑–∞–ø—Ä–æ—Å–æ–≤
   - ‚úÖ Singleton Pattern –¥–ª—è –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ (i18n, settings)

2. **–ö–∞—á–µ—Å—Ç–≤–æ –∫–æ–¥–∞:**
   - ‚úÖ –°—Ç—Ä–æ–≥–∞—è —Ç–∏–ø–∏–∑–∞—Ü–∏—è —Å Mypy (Python 3.11+)
   - ‚úÖ –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –∞–Ω–Ω–æ—Ç–∞—Ü–∏–∏ —Ç–∏–ø–æ–≤ (`list[str]` –≤–º–µ—Å—Ç–æ `List[str]`)
   - ‚úÖ Docstrings –≤ Google-—Å—Ç–∏–ª–µ –¥–ª—è –≤—Å–µ—Ö –ø—É–±–ª–∏—á–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π
   - ‚úÖ Ruff –¥–ª—è –ª–∏–Ω—Ç–∏–Ω–≥–∞ (100 —Å–∏–º–≤–æ–ª–æ–≤ –Ω–∞ —Å—Ç—Ä–æ–∫—É)
   - ‚úÖ Async/await –≤–µ–∑–¥–µ –≥–¥–µ –Ω—É–∂–Ω–æ

3. **–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å:**
   - ‚úÖ –ú–Ω–æ–≥–æ—è–∑—ã—á–Ω–æ—Å—Ç—å (—Ä—É—Å—Å–∫–∏–π, –∞–Ω–≥–ª–∏–π—Å–∫–∏–π, —á–µ—à—Å–∫–∏–π) —á–µ—Ä–µ–∑ Babel
   - ‚úÖ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –ø–ª–∞—Ç–µ–∂–µ–π —á–µ—Ä–µ–∑ Tribute API
   - ‚úÖ –°–∏—Å—Ç–µ–º–∞ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–≤ –¥–ª—è –±–µ—Å–ø–ª–∞—Ç–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
   - ‚úÖ Redis –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–µ—Å—Å–∏—è–º–∏ —Å TTL
   - ‚úÖ SQLAlchemy 2.0+ —Å –º–∏–≥—Ä–∞—Ü–∏—è–º–∏ Alembic
   - ‚úÖ –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –∫–∞—Ä—Ç–æ—á–µ–∫ —Å –≤–æ–ø—Ä–æ—Å–∞–º–∏ –≤ PNG/JPEG
   - ‚úÖ –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ (structlog) –∏ Sentry

4. **–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:**
   - ‚úÖ Pytest —Å async –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π
   - ‚úÖ –ü–æ–∫—Ä—ã—Ç–∏–µ —Ç–µ—Å—Ç–∞–º–∏ ~80%
   - ‚úÖ –ö–æ–º–ø–ª–µ–∫—Å–Ω—ã–µ unit –∏ integration —Ç–µ—Å—Ç—ã
   - ‚úÖ –ú–æ–∫–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–Ω–µ—à–Ω–∏—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π

5. **DevOps:**
   - ‚úÖ Docker —Å multi-stage —Å–±–æ—Ä–∫–æ–π
   - ‚úÖ –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ –¥–µ–ø–ª–æ—é –Ω–∞ Render.com –∏ Railway
   - ‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –º–∏–≥—Ä–∞—Ü–∏–∏ –ë–î
   - ‚úÖ Health check endpoints
   - ‚úÖ Environment variables validation —á–µ—Ä–µ–∑ Pydantic

### –û–±–ª–∞—Å—Ç–∏ –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è ‚ö†Ô∏è

1. **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:**
   - ‚ö†Ô∏è –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è —á–∞—Å—Ç–æ –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º—ã—Ö –¥–∞–Ω–Ω—ã—Ö (–∏–≥—Ä–æ–≤–æ–π –∫–æ–Ω—Ç–µ–Ω—Ç)
   - ‚ö†Ô∏è –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–¥–ª–µ–Ω–Ω—ã–º –ø—Ä–∏ –≤—ã—Å–æ–∫–æ–π –Ω–∞–≥—Ä—É–∑–∫–µ
   - ‚ö†Ô∏è –ù–µ—Ç rate limiting –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π (—Ç–æ–ª—å–∫–æ –¥–ª—è webhook)
   - ‚ö†Ô∏è Connection pooling –¥–ª—è Redis –Ω–∞—Å—Ç—Ä–æ–µ–Ω (max_connections=20), –Ω–æ –º–æ–∂–Ω–æ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å

2. **–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å:**
   - ‚ö†Ô∏è –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞ (voice messages)
   - ‚ö†Ô∏è –ù–µ—Ç –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (–∫–∞–∫–∏–µ —Ç–µ–º—ã/–≤–æ–ø—Ä–æ—Å—ã –ø–æ–ø—É–ª—è—Ä–Ω—ã)
   - ‚ö†Ô∏è –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–∏ (—Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏—Å—Ç–æ—Ä–∏–∏)
   - ‚ö†Ô∏è –ù–µ—Ç –≥—Ä—É–ø–ø–æ–≤—ã—Ö –∏–≥—Ä/—Å–µ—Å—Å–∏–π
   - ‚ö†Ô∏è –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π/—É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –¥–ª—è —Ä–µ–≥—É–ª—è—Ä–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
   - ‚ö†Ô∏è –ù–µ—Ç —Å–∏—Å—Ç–µ–º—ã –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π/–≥–µ–π–º–∏—Ñ–∏–∫–∞—Ü–∏–∏

3. **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å:**
   - ‚ö†Ô∏è CSRF protection —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω –Ω–æ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ handlers
   - ‚ö†Ô∏è Input sanitization –µ—Å—Ç—å, –Ω–æ –Ω–µ –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –≤–µ–∑–¥–µ
   - ‚ö†Ô∏è –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ rate limiting –Ω–∞ —É—Ä–æ–≤–Ω–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –∫–æ–º–∞–Ω–¥ –±–æ—Ç–∞

4. **–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥:**
   - ‚ö†Ô∏è Sentry –Ω–∞—Å—Ç—Ä–æ–µ–Ω, –Ω–æ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –±–æ–ª—å—à–µ –º–µ—Ç—Ä–∏–∫ (Prometheus/Grafana)
   - ‚ö†Ô∏è –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –∞–ª–µ—Ä—Ç–æ–≤ –ø—Ä–∏ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –æ—à–∏–±–∫–∞—Ö
   - ‚ö†Ô∏è –ù–µ—Ç dashboard –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∑–¥–æ—Ä–æ–≤—å—è —Å–∏—Å—Ç–µ–º—ã

---

## üöÄ –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –ø–æ –Ω–æ–≤—ã–º —Ñ—É–Ω–∫—Ü–∏—è–º

### 1. üé§ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è OpenAI Whisper –¥–ª—è –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞ (–ü–†–ò–û–†–ò–¢–ï–¢: –í–´–°–û–ö–ò–ô)

#### –û–ø–∏—Å–∞–Ω–∏–µ
–î–æ–±–∞–≤–∏—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –≥–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤–º–µ—Å—Ç–æ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤ –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã. Whisper API –æ—Ç OpenAI –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –≥–æ–ª–æ—Å –≤ —Ç–µ–∫—Å—Ç –Ω–∞ –ª—é–±–æ–º –∏–∑ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã—Ö —è–∑—ã–∫–æ–≤.

#### –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞
- üó£Ô∏è **–ï—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å –æ–±—â–µ–Ω–∏—è:** –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –º–æ–≥—É—Ç –æ—Ç–≤–µ—á–∞—Ç—å –≥–æ–ª–æ—Å–æ–º, —á—Ç–æ –¥–µ–ª–∞–µ—Ç –∏–≥—Ä—É –±–æ–ª–µ–µ –∏–Ω—Ç–∏–º–Ω–æ–π
- üåç **–ú–Ω–æ–≥–æ—è–∑—ã—á–Ω–æ—Å—Ç—å:** Whisper –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç 50+ —è–∑—ã–∫–æ–≤, –≤–∫–ª—é—á–∞—è —Ä—É—Å—Å–∫–∏–π, –∞–Ω–≥–ª–∏–π—Å–∫–∏–π –∏ —á–µ—à—Å–∫–∏–π
- ‚ö° **–ë—ã—Å—Ç—Ä–æ—Ç–∞:** –¢—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏—è –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –∑–∞ 2-3 —Å–µ–∫—É–Ω–¥—ã
- ‚ôø **–î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å:** –£–¥–æ–±–Ω–æ –¥–ª—è –ª—é–¥–µ–π, –∫–æ—Ç–æ—Ä—ã–º —Å–ª–æ–∂–Ω–æ –ø–µ—á–∞—Ç–∞—Ç—å
- üìä **–ê–Ω–∞–ª–∏—Ç–∏–∫–∞:** –ú–æ–∂–Ω–æ –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –¥–ª–∏–Ω—É –∏ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å –æ—Ç–≤–µ—Ç–æ–≤

#### –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è

```python
# vechnost_bot/voice_handler.py
"""Voice message handler using OpenAI Whisper API."""

import logging
from pathlib import Path
from typing import Optional
import aiofiles
from openai import AsyncOpenAI
from telegram import Update, Voice
from telegram.ext import ContextTypes

from .config import settings
from .i18n import Language, get_text
from .monitoring import track_performance, log_bot_event

logger = logging.getLogger(__name__)


class VoiceTranscriptionService:
    """Service for transcribing voice messages using OpenAI Whisper."""

    def __init__(self):
        self.client = AsyncOpenAI(api_key=settings.openai_api_key)
        self.temp_dir = Path("temp/voice")
        self.temp_dir.mkdir(parents=True, exist_ok=True)

    @track_performance("transcribe_voice")
    async def transcribe_voice_message(
        self,
        voice: Voice,
        language: Language,
        context: ContextTypes.DEFAULT_TYPE
    ) -> Optional[str]:
        """
        Transcribe a Telegram voice message to text.

        Args:
            voice: Telegram Voice object
            language: Target language for transcription
            context: Bot context for file download

        Returns:
            Transcribed text or None if error
        """
        temp_file = None
        try:
            # Download voice file
            voice_file = await context.bot.get_file(voice.file_id)
            temp_file = self.temp_dir / f"{voice.file_id}.ogg"

            await voice_file.download_to_drive(temp_file)

            logger.info(
                f"Voice file downloaded: {temp_file} "
                f"(duration: {voice.duration}s, size: {voice.file_size} bytes)"
            )

            # Transcribe using Whisper
            async with aiofiles.open(temp_file, "rb") as audio_file:
                audio_data = await audio_file.read()

                transcription = await self.client.audio.transcriptions.create(
                    model="whisper-1",
                    file=("audio.ogg", audio_data, "audio/ogg"),
                    response_format="verbose_json",
                    language=language.value,  # en, ru, cs
                    temperature=0.0,  # More deterministic
                )

            text = transcription.text
            detected_language = transcription.language
            duration = transcription.duration

            logger.info(
                f"Voice transcribed successfully: length={len(text)}, "
                f"detected_language={detected_language}, duration={duration}s"
            )

            log_bot_event(
                "voice_transcribed",
                text_length=len(text),
                voice_duration=voice.duration,
                detected_language=detected_language,
            )

            return text

        except Exception as e:
            logger.error(f"Error transcribing voice message: {e}", exc_info=True)
            log_bot_event("voice_transcription_error", error=str(e))
            return None

        finally:
            # Cleanup temp file
            if temp_file and temp_file.exists():
                try:
                    temp_file.unlink()
                except Exception as e:
                    logger.warning(f"Failed to delete temp file {temp_file}: {e}")


# Global service instance
voice_service = VoiceTranscriptionService()


async def handle_voice_message(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE
) -> None:
    """
    Handle incoming voice messages.

    Args:
        update: Telegram update with voice message
        context: Bot context
    """
    if not update.message or not update.message.voice:
        return

    chat_id = update.effective_chat.id
    user_id = update.effective_user.id

    # Import here to avoid circular dependency
    from .storage import get_session

    # Get user session for language preference
    session = await get_session(chat_id)
    language = session.language

    # Show "typing..." indicator
    await context.bot.send_chat_action(chat_id=chat_id, action="typing")

    # Inform user about transcription
    processing_msg = await update.message.reply_text(
        get_text("voice.processing", language)
    )

    # Transcribe voice message
    transcribed_text = await voice_service.transcribe_voice_message(
        update.message.voice, language, context
    )

    # Delete processing message
    await processing_msg.delete()

    if transcribed_text:
        # Send transcribed text back to user
        response = get_text("voice.transcribed", language).format(
            text=transcribed_text
        )
        await update.message.reply_text(response)

        # Log the interaction
        log_bot_event(
            "voice_message_handled",
            user_id=user_id,
            text_length=len(transcribed_text),
        )
    else:
        # Error occurred
        error_msg = get_text("voice.error", language)
        await update.message.reply_text(error_msg)


# Add to bot.py:
# from .voice_handler import handle_voice_message
# application.add_handler(MessageHandler(filters.VOICE, handle_voice_message))
```

#### –ò–∑–º–µ–Ω–µ–Ω–∏—è –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏

```python
# vechnost_bot/config.py - –¥–æ–±–∞–≤–∏—Ç—å –≤ Settings –∫–ª–∞—Å—Å:

openai_api_key: Optional[str] = Field(
    default=None,
    validation_alias="OPENAI_API_KEY",
    description="OpenAI API key for Whisper transcription"
)

enable_voice_transcription: bool = Field(
    default=False,
    validation_alias="ENABLE_VOICE_TRANSCRIPTION",
    description="Enable voice message transcription"
)
```

#### –ü–µ—Ä–µ–≤–æ–¥—ã –¥–ª—è –≥–æ–ª–æ—Å–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π

```yaml
# data/translations_ru.yaml
voice:
  processing: "üé§ –†–∞—Å–ø–æ–∑–Ω–∞—é –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ..."
  transcribed: "üìù –í—ã —Å–∫–∞–∑–∞–ª–∏:\n\n{text}"
  error: "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑."
  not_enabled: "üîá –ì–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–∫–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è."

# data/translations_en.yaml
voice:
  processing: "üé§ Transcribing voice message..."
  transcribed: "üìù You said:\n\n{text}"
  error: "‚ùå Failed to transcribe voice message. Please try again."
  not_enabled: "üîá Voice messages are not supported yet."

# data/translations_cs.yaml
voice:
  processing: "üé§ P≈ôepisuji hlasovou zpr√°vu..."
  transcribed: "üìù ≈òekli jste:\n\n{text}"
  error: "‚ùå Nepoda≈ôilo se p≈ôepsat hlasovou zpr√°vu. Zkuste to znovu."
  not_enabled: "üîá Hlasov√© zpr√°vy zat√≠m nejsou podporov√°ny."
```

#### –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏

```toml
# pyproject.toml - –¥–æ–±–∞–≤–∏—Ç—å –≤ dependencies:
"openai>=1.68.0",  # For Whisper API
"aiofiles>=23.0.0",  # Already present
```

#### –¢–µ—Å—Ç—ã

```python
# tests/test_voice_handler.py
"""Tests for voice message handler."""

import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from pathlib import Path

from vechnost_bot.voice_handler import VoiceTranscriptionService, handle_voice_message
from vechnost_bot.i18n import Language


class TestVoiceTranscriptionService:
    """Test voice transcription service."""

    @pytest.mark.asyncio
    async def test_transcribe_voice_success(self):
        """Test successful voice transcription."""
        service = VoiceTranscriptionService()

        # Mock OpenAI client
        with patch.object(service, 'client') as mock_client:
            mock_response = MagicMock()
            mock_response.text = "–ü—Ä–∏–≤–µ—Ç, –∫–∞–∫ –¥–µ–ª–∞?"
            mock_response.language = "ru"
            mock_response.duration = 3.5

            mock_client.audio.transcriptions.create = AsyncMock(
                return_value=mock_response
            )

            # Mock Telegram objects
            voice = MagicMock()
            voice.file_id = "test_file_id"
            voice.duration = 3
            voice.file_size = 12345

            context = MagicMock()
            voice_file = MagicMock()
            voice_file.download_to_drive = AsyncMock()
            context.bot.get_file = AsyncMock(return_value=voice_file)

            # Transcribe
            result = await service.transcribe_voice_message(
                voice, Language.RUSSIAN, context
            )

            assert result == "–ü—Ä–∏–≤–µ—Ç, –∫–∞–∫ –¥–µ–ª–∞?"
            mock_client.audio.transcriptions.create.assert_called_once()

    @pytest.mark.asyncio
    async def test_transcribe_voice_error(self):
        """Test voice transcription error handling."""
        service = VoiceTranscriptionService()

        # Mock OpenAI client to raise exception
        with patch.object(service, 'client') as mock_client:
            mock_client.audio.transcriptions.create = AsyncMock(
                side_effect=Exception("API Error")
            )

            voice = MagicMock()
            voice.file_id = "test_file_id"
            context = MagicMock()
            context.bot.get_file = AsyncMock()

            result = await service.transcribe_voice_message(
                voice, Language.RUSSIAN, context
            )

            assert result is None


class TestVoiceMessageHandler:
    """Test voice message handler."""

    @pytest.mark.asyncio
    async def test_handle_voice_message(self):
        """Test handling of voice message."""
        update = MagicMock()
        update.message = MagicMock()
        update.message.voice = MagicMock()
        update.effective_chat = MagicMock()
        update.effective_chat.id = 12345
        update.effective_user = MagicMock()
        update.effective_user.id = 67890

        context = MagicMock()
        context.bot.send_chat_action = AsyncMock()
        update.message.reply_text = AsyncMock()

        # Mock voice service
        with patch('vechnost_bot.voice_handler.voice_service') as mock_service:
            mock_service.transcribe_voice_message = AsyncMock(
                return_value="Test transcription"
            )

            await handle_voice_message(update, context)

            # Verify transcription was called
            mock_service.transcribe_voice_message.assert_called_once()

            # Verify response was sent
            update.message.reply_text.assert_called()
```

#### –°—Ç–æ–∏–º–æ—Å—Ç—å –∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å

- **–°—Ç–æ–∏–º–æ—Å—Ç—å:** $0.006 –∑–∞ –º–∏–Ω—É—Ç—É –∞—É–¥–∏–æ (Whisper API)
- **–°—Ä–µ–¥–Ω—è—è –¥–ª–∏–Ω–∞ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è:** 10-30 —Å–µ–∫—É–Ω–¥
- **–°—Ç–æ–∏–º–æ—Å—Ç—å –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ:** ~$0.001-0.003
- **–í—Ä–µ–º—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏:** 2-5 —Å–µ–∫—É–Ω–¥
- **Rate limit:** 50 –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –º–∏–Ω—É—Ç—É (OpenAI default)

#### –î–æ—Ä–æ–∂–Ω–∞—è –∫–∞—Ä—Ç–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏

1. **–§–∞–∑–∞ 1 (1-2 –¥–Ω—è):**
   - –î–æ–±–∞–≤–∏—Ç—å OpenAI SDK –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
   - –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å `VoiceTranscriptionService`
   - –î–æ–±–∞–≤–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –≥–æ–ª–æ—Å–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
   - –ù–∞–ø–∏—Å–∞—Ç—å unit —Ç–µ—Å—Ç—ã

2. **–§–∞–∑–∞ 2 (1 –¥–µ–Ω—å):**
   - –î–æ–±–∞–≤–∏—Ç—å –ø–µ—Ä–µ–≤–æ–¥—ã –¥–ª—è –≤—Å–µ—Ö —è–∑—ã–∫–æ–≤
   - –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ handlers
   - –î–æ–±–∞–≤–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ

3. **–§–∞–∑–∞ 3 (1-2 –¥–Ω—è):**
   - –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ —Å –º–∞–ª–æ–π –≥—Ä—É–ø–ø–æ–π
   - –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
   - –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π

---

### 2. üéôÔ∏è –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≥–æ–ª–æ—Å–æ–≤—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤ —á–µ—Ä–µ–∑ OpenAI TTS (–ü–†–ò–û–†–ò–¢–ï–¢: –°–†–ï–î–ù–ò–ô)

#### –û–ø–∏—Å–∞–Ω–∏–µ
–ü–æ–º–∏–º–æ –ø—Ä–∏–µ–º–∞ –≥–æ–ª–æ—Å–∞ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –º–æ–∂–Ω–æ –æ–∑–≤—É—á–∏–≤–∞—Ç—å —Å–∞–º–∏ –≤–æ–ø—Ä–æ—Å—ã –∏–∑ –∫–∞—Ä—Ç–æ—á–µ–∫ —á–µ—Ä–µ–∑ OpenAI Text-to-Speech API. –≠—Ç–æ —Å–¥–µ–ª–∞–µ—Ç –∏–≥—Ä—É –µ—â–µ –±–æ–ª–µ–µ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–π.

#### –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞
- üé≠ **–ê—Ç–º–æ—Å—Ñ–µ—Ä–∞:** –ì–æ–ª–æ—Å–æ–≤–æ–µ –æ–∑–≤—É—á–∏–≤–∞–Ω–∏–µ —Å–æ–∑–¥–∞–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—É—é –∞—Ç–º–æ—Å—Ñ–µ—Ä—É
- üëÇ **–£–¥–æ–±—Å—Ç–≤–æ:** –ú–æ–∂–Ω–æ —Å–ª—É—à–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã –≤–º–µ—Å—Ç–æ —á—Ç–µ–Ω–∏—è
- üåê **–ú–Ω–æ–≥–æ—è–∑—ã—á–Ω–æ—Å—Ç—å:** TTS –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –≤—Å–µ —è–∑—ã–∫–∏ –±–æ—Ç–∞
- ‚ôø **–î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å:** –ü–æ–º–æ—â—å –ª—é–¥—è–º —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º–∏ –∑—Ä–µ–Ω–∏—è

#### –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è

```python
# vechnost_bot/tts_service.py
"""Text-to-speech service using OpenAI TTS API."""

import logging
from pathlib import Path
from typing import Optional
import hashlib
from openai import AsyncOpenAI

from .config import settings
from .i18n import Language
from .monitoring import track_performance

logger = logging.getLogger(__name__)


class TTSService:
    """Service for converting text to speech."""

    # Voice mapping for different languages
    VOICE_MAP = {
        Language.RUSSIAN: "nova",  # Female voice, sounds good in Russian
        Language.ENGLISH: "alloy",  # Neutral voice
        Language.CZECH: "shimmer",  # Female voice
    }

    def __init__(self):
        self.client = AsyncOpenAI(api_key=settings.openai_api_key)
        self.cache_dir = Path("cache/tts")
        self.cache_dir.mkdir(parents=True, exist_ok=True)

    def _get_cache_key(self, text: str, language: Language) -> str:
        """Generate cache key for TTS audio."""
        content = f"{text}:{language.value}".encode('utf-8')
        return hashlib.sha256(content).hexdigest()[:16]

    def _get_cache_path(self, cache_key: str) -> Path:
        """Get cache file path."""
        return self.cache_dir / f"{cache_key}.mp3"

    @track_performance("generate_tts")
    async def text_to_speech(
        self,
        text: str,
        language: Language
    ) -> Optional[Path]:
        """
        Convert text to speech audio file.

        Args:
            text: Text to convert
            language: Language for speech synthesis

        Returns:
            Path to audio file or None if error
        """
        try:
            # Check cache first
            cache_key = self._get_cache_key(text, language)
            cache_path = self._get_cache_path(cache_key)

            if cache_path.exists():
                logger.debug(f"TTS cache hit: {cache_key}")
                return cache_path

            # Generate speech
            voice = self.VOICE_MAP.get(language, "alloy")

            response = await self.client.audio.speech.create(
                model="tts-1",  # or "tts-1-hd" for higher quality
                voice=voice,
                input=text[:4096],  # TTS API limit
                response_format="mp3",
            )

            # Save to cache
            await response.awrite_to_file(cache_path)

            logger.info(
                f"TTS generated: {cache_key} (language={language.value}, "
                f"voice={voice}, text_length={len(text)})"
            )

            return cache_path

        except Exception as e:
            logger.error(f"Error generating TTS: {e}", exc_info=True)
            return None


# Global service instance
tts_service = TTSService()
```

#### –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ handlers.py

```python
# –î–æ–±–∞–≤–∏—Ç—å –≤ handle_question_selection():

# After getting the question text
question = items[index]

# Generate voice version if enabled
if settings.enable_tts:
    audio_path = await tts_service.text_to_speech(question, session.language)
    if audio_path:
        # Send audio along with image
        await query.message.reply_audio(
            audio=open(audio_path, 'rb'),
            caption=get_text('question.audio_caption', session.language)
        )
```

#### –°—Ç–æ–∏–º–æ—Å—Ç—å
- **–°—Ç–æ–∏–º–æ—Å—Ç—å:** $15 –∑–∞ 1 –º–∏–ª–ª–∏–æ–Ω —Å–∏–º–≤–æ–ª–æ–≤ (TTS API)
- **–°—Ä–µ–¥–Ω—è—è –¥–ª–∏–Ω–∞ –≤–æ–ø—Ä–æ—Å–∞:** 100 —Å–∏–º–≤–æ–ª–æ–≤
- **–°—Ç–æ–∏–º–æ—Å—Ç—å –Ω–∞ –≤–æ–ø—Ä–æ—Å:** ~$0.0015
- **–ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ:** –ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ —Å–Ω–∏–∂–∞–µ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç—å –ø—Ä–∏ –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–∞—Ö

---

### 3. üìä –°–∏—Å—Ç–µ–º–∞ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –∏ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–∏ (–ü–†–ò–û–†–ò–¢–ï–¢: –°–†–ï–î–ù–ò–ô)

#### –û–ø–∏—Å–∞–Ω–∏–µ
–î–æ–±–∞–≤–∏—Ç—å —Å–±–æ—Ä –∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö –æ –ø–æ–≤–µ–¥–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è –∏–≥—Ä—ã –∏ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞.

#### –ß—Ç–æ –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å

```python
# vechnost_bot/analytics.py
"""Analytics service for user behavior tracking."""

from datetime import datetime
from typing import Dict, Any, Optional
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession

from .payments.database import get_db
from .payments.models import Base, User
from sqlalchemy import Column, Integer, BigInteger, String, DateTime, ForeignKey
from sqlalchemy.orm import Mapped, mapped_column


class UserAction(Base):
    """Model for tracking user actions."""

    __tablename__ = "user_actions"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    telegram_user_id: Mapped[int] = mapped_column(BigInteger, nullable=False)
    action_type: Mapped[str] = mapped_column(String, nullable=False)
    theme: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    level: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    question_index: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    content_type: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    duration_seconds: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    created_at: Mapped[datetime] = mapped_column(
        DateTime, default=datetime.utcnow, nullable=False
    )


class AnalyticsService:
    """Service for analytics and personalization."""

    @staticmethod
    async def track_action(
        telegram_user_id: int,
        action_type: str,
        **metadata
    ) -> None:
        """Track user action."""
        async with get_db() as session:
            action = UserAction(
                telegram_user_id=telegram_user_id,
                action_type=action_type,
                theme=metadata.get('theme'),
                level=metadata.get('level'),
                question_index=metadata.get('question_index'),
                content_type=metadata.get('content_type'),
                duration_seconds=metadata.get('duration'),
            )
            session.add(action)
            await session.commit()

    @staticmethod
    async def get_popular_themes() -> Dict[str, int]:
        """Get most popular themes."""
        async with get_db() as session:
            result = await session.execute(
                select(
                    UserAction.theme,
                    func.count(UserAction.id).label('count')
                )
                .where(UserAction.theme.isnot(None))
                .group_by(UserAction.theme)
                .order_by(func.count(UserAction.id).desc())
            )
            return {row.theme: row.count for row in result}

    @staticmethod
    async def get_user_favorite_theme(telegram_user_id: int) -> Optional[str]:
        """Get user's most used theme."""
        async with get_db() as session:
            result = await session.execute(
                select(
                    UserAction.theme,
                    func.count(UserAction.id).label('count')
                )
                .where(UserAction.telegram_user_id == telegram_user_id)
                .where(UserAction.theme.isnot(None))
                .group_by(UserAction.theme)
                .order_by(func.count(UserAction.id).desc())
                .limit(1)
            )
            row = result.first()
            return row.theme if row else None


# Usage in handlers:
await AnalyticsService.track_action(
    telegram_user_id=user_id,
    action_type="question_viewed",
    theme=session.theme.value,
    level=session.level,
    question_index=index,
)
```

---

### 4. üéÆ –ì—Ä—É–ø–ø–æ–≤—ã–µ –∏–≥—Ä–æ–≤—ã–µ —Å–µ—Å—Å–∏–∏ (–ü–†–ò–û–†–ò–¢–ï–¢: –ù–ò–ó–ö–ò–ô)

#### –û–ø–∏—Å–∞–Ω–∏–µ
–†–∞–∑—Ä–µ—à–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –∏–≥—Ä–∞—Ç—å –≤–º–µ—Å—Ç–µ –≤ –æ–¥–Ω–æ–π —Å–µ—Å—Å–∏–∏ —á–µ—Ä–µ–∑ –≥—Ä—É–ø–ø—É –∏–ª–∏ –∫–∞–Ω–∞–ª.

#### –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å
- –°–æ–∑–¥–∞–Ω–∏–µ –≥—Ä—É–ø–ø–æ–≤–æ–π —Å–µ—Å—Å–∏–∏
- –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —á–µ—Ä–µ–∑ —Å—Å—ã–ª–∫—É
- –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∫–∞—Ä—Ç–æ—á–µ–∫ –¥–ª—è –≤—Å–µ—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
- –û—á–µ—Ä–µ–¥–Ω–æ—Å—Ç—å –æ—Ç–≤–µ—Ç–æ–≤
- –ì—Ä—É–ø–ø–æ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞

---

### 5. üèÜ –ì–µ–π–º–∏—Ñ–∏–∫–∞—Ü–∏—è –∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è (–ü–†–ò–û–†–ò–¢–ï–¢: –ù–ò–ó–ö–ò–ô)

#### –û–ø–∏—Å–∞–Ω–∏–µ
–î–æ–±–∞–≤–∏—Ç—å —Å–∏—Å—Ç–µ–º—É –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π, –±–µ–π–¥–∂–µ–π –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –¥–ª—è –º–æ—Ç–∏–≤–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.

#### –ü—Ä–∏–º–µ—Ä—ã –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
- üéØ "–ü–µ—Ä–≤—ã–π —à–∞–≥" - –û—Ç–≤–µ—Ç–∏–ª –Ω–∞ 10 –≤–æ–ø—Ä–æ—Å–æ–≤
- üíë "–í–ª—é–±–ª–µ–Ω–Ω—ã–µ" - –ü—Ä–æ—à–µ–ª –≤—Å–µ —É—Ä–æ–≤–Ω–∏ —Ç–µ–º—ã "–î–ª—è –ø–∞—Ä"
- üî• "–°—Ç—Ä–∞—Å—Ç–Ω—ã–π" - –ü—Ä–æ—à–µ–ª —Ç–µ–º—É "–°–µ–∫—Å"
- üìÖ "–ü–æ—Å—Ç–æ—è–Ω–Ω—ã–π –∏–≥—Ä–æ–∫" - –ò–≥—Ä–∞–ª 7 –¥–Ω–µ–π –ø–æ–¥—Ä—è–¥
- üåü "–ü–æ–ª–∏–≥–ª–æ—Ç" - –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –≤—Å–µ 3 —è–∑—ã–∫–∞

---

### 6. üîî –°–∏—Å—Ç–µ–º–∞ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π (–ü–†–ò–û–†–ò–¢–ï–¢: –ù–ò–ó–ö–ò–ô)

#### –û–ø–∏—Å–∞–Ω–∏–µ
–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è –≤–æ–≤–ª–µ—á–µ–Ω–Ω–æ—Å—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.

#### –¢–∏–ø—ã –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π
- –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –≤–æ–ø—Ä–æ—Å –¥–Ω—è
- –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –æ –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω–æ–π —Ç–µ–º–µ
- –ù–æ–≤—ã–µ –∫–∞—Ä—Ç–æ—á–∫–∏/—Ç–µ–º—ã
- –ü–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏

---

### 7. ü§ñ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å ChatGPT –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–∞—Å—Ç–æ–º–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤ (–ü–†–ò–û–†–ò–¢–ï–¢: –°–†–ï–î–ù–ò–ô)

#### –û–ø–∏—Å–∞–Ω–∏–µ
–ü–æ–∑–≤–æ–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏—Ö –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–π —á–µ—Ä–µ–∑ ChatGPT API.

```python
# vechnost_bot/question_generator.py
"""Custom question generator using ChatGPT."""

from openai import AsyncOpenAI
from .config import settings
from .i18n import Language


class QuestionGenerator:
    """Generate custom questions using ChatGPT."""

    def __init__(self):
        self.client = AsyncOpenAI(api_key=settings.openai_api_key)

    async def generate_questions(
        self,
        theme: str,
        level: int,
        language: Language,
        count: int = 5,
    ) -> list[str]:
        """Generate custom questions."""

        prompts = {
            Language.RUSSIAN: f"–°–≥–µ–Ω–µ—Ä–∏—Ä—É–π {count} –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤ –¥–ª—è –∏–≥—Ä—ã –º–µ–∂–¥—É –ø–∞—Ä–æ–π –Ω–∞ —Ç–µ–º—É '{theme}', —É—Ä–æ–≤–µ–Ω—å –∏–Ω—Ç–∏–º–Ω–æ—Å—Ç–∏ {level}/3.",
            Language.ENGLISH: f"Generate {count} interesting questions for a couple's game on the theme '{theme}', intimacy level {level}/3.",
            Language.CZECH: f"Vygeneruj {count} zaj√≠mav√Ωch ot√°zek pro hru pro p√°ry na t√©ma '{theme}', √∫rove≈à intimity {level}/3.",
        }

        response = await self.client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {
                    "role": "system",
                    "content": "You are a relationship coach creating meaningful questions for couples."
                },
                {
                    "role": "user",
                    "content": prompts[language]
                }
            ],
            temperature=0.9,
            max_tokens=500,
        )

        # Parse questions from response
        content = response.choices[0].message.content
        questions = [q.strip() for q in content.split('\n') if q.strip() and not q.strip().startswith('#')]

        return questions[:count]
```

---

## üîß –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —É–ª—É—á—à–µ–Ω–∏—è

### 1. –ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞

```python
# vechnost_bot/cache_manager.py
"""Cache manager for frequently accessed data."""

from functools import lru_cache
import redis.asyncio as redis
from typing import Optional, Any
import json
import pickle

class CacheManager:
    """Unified cache manager."""

    def __init__(self):
        self.redis_client: Optional[redis.Redis] = None
        self.local_cache: dict = {}

    async def get(self, key: str) -> Optional[Any]:
        """Get value from cache."""
        # Try Redis first
        if self.redis_client:
            value = await self.redis_client.get(key)
            if value:
                return pickle.loads(value)

        # Fallback to local cache
        return self.local_cache.get(key)

    async def set(self, key: str, value: Any, ttl: int = 3600) -> None:
        """Set value in cache."""
        if self.redis_client:
            await self.redis_client.setex(
                key, ttl, pickle.dumps(value)
            )
        else:
            self.local_cache[key] = value
```

### 2. Rate Limiting –¥–ª—è –∫–æ–º–∞–Ω–¥ –±–æ—Ç–∞

```python
# vechnost_bot/rate_limiter.py - —É–ª—É—á—à–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π
"""Enhanced rate limiter for bot commands."""

from collections import defaultdict
from datetime import datetime, timedelta
from typing import Dict, Tuple

class BotRateLimiter:
    """Rate limiter for bot commands."""

    def __init__(self):
        self.user_commands: Dict[int, list[datetime]] = defaultdict(list)
        self.limits = {
            'default': (10, 60),  # 10 commands per 60 seconds
            'start': (3, 60),     # 3 starts per 60 seconds
            'voice': (5, 60),     # 5 voice messages per 60 seconds
        }

    def is_allowed(
        self,
        user_id: int,
        command: str = 'default'
    ) -> Tuple[bool, int]:
        """
        Check if user is allowed to execute command.

        Returns:
            (is_allowed, seconds_to_wait)
        """
        limit, window = self.limits.get(command, self.limits['default'])
        now = datetime.now()
        cutoff = now - timedelta(seconds=window)

        # Clean old timestamps
        self.user_commands[user_id] = [
            ts for ts in self.user_commands[user_id]
            if ts > cutoff
        ]

        # Check limit
        if len(self.user_commands[user_id]) >= limit:
            oldest = self.user_commands[user_id][0]
            wait_time = int((oldest + timedelta(seconds=window) - now).total_seconds())
            return False, wait_time

        # Allow and record
        self.user_commands[user_id].append(now)
        return True, 0


# Apply to handlers:
bot_rate_limiter = BotRateLimiter()

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id

    allowed, wait_time = bot_rate_limiter.is_allowed(user_id, 'start')
    if not allowed:
        await update.message.reply_text(
            f"‚è±Ô∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ {wait_time} —Å–µ–∫—É–Ω–¥ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –∫–æ–º–∞–Ω–¥–æ–π."
        )
        return

    # ... rest of handler
```

### 3. Prometheus –º–µ—Ç—Ä–∏–∫–∏

```python
# vechnost_bot/metrics.py
"""Prometheus metrics for monitoring."""

from prometheus_client import Counter, Histogram, Gauge, start_http_server

# Metrics
commands_total = Counter(
    'bot_commands_total',
    'Total number of bot commands',
    ['command', 'user_id']
)

voice_messages_total = Counter(
    'bot_voice_messages_total',
    'Total number of voice messages transcribed',
    ['language', 'status']
)

transcription_duration = Histogram(
    'bot_transcription_duration_seconds',
    'Time spent transcribing voice messages'
)

active_sessions = Gauge(
    'bot_active_sessions',
    'Number of active user sessions'
)

# Start metrics server
def start_metrics_server(port: int = 9090) -> None:
    """Start Prometheus metrics HTTP server."""
    start_http_server(port)
```

---

## üìã –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏

### –í—ã—Å–æ–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç (1-2 –Ω–µ–¥–µ–ª–∏)
1. ‚úÖ **OpenAI Whisper –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è** - –ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥
2. ‚úÖ **Rate Limiting —É–ª—É—á—à–µ–Ω–∏–µ** - –ó–∞—â–∏—Ç–∞ –æ—Ç —Å–ø–∞–º–∞
3. ‚úÖ **–ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ** - –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å

### –°—Ä–µ–¥–Ω–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç (2-4 –Ω–µ–¥–µ–ª–∏)
4. ‚ö†Ô∏è **OpenAI TTS** - –û–∑–≤—É—á–∏–≤–∞–Ω–∏–µ –≤–æ–ø—Ä–æ—Å–æ–≤
5. ‚ö†Ô∏è **–ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –∏ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏—è** - –£–ª—É—á—à–µ–Ω–∏–µ UX
6. ‚ö†Ô∏è **ChatGPT –∫–∞—Å—Ç–æ–º–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã** - –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞

### –ù–∏–∑–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç (1-3 –º–µ—Å—è—Ü–∞)
7. üìÖ **–ì—Ä—É–ø–ø–æ–≤—ã–µ —Å–µ—Å—Å–∏–∏** - –°–æ—Ü–∏–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
8. üìÖ **–ì–µ–π–º–∏—Ñ–∏–∫–∞—Ü–∏—è** - –ú–æ—Ç–∏–≤–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
9. üìÖ **–°–∏—Å—Ç–µ–º–∞ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π** - –£–¥–µ—Ä–∂–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π

---

## üí∞ –û—Ü–µ–Ω–∫–∞ —Å—Ç–æ–∏–º–æ—Å—Ç–∏ OpenAI API

### –ú–µ—Å—è—á–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ (1000 –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π)

| –§—É–Ω–∫—Ü–∏—è | –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ | –°—Ç–æ–∏–º–æ—Å—Ç—å –∑–∞ –µ–¥–∏–Ω–∏—Ü—É | –ú–µ—Å—è—á–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å |
|---------|--------------|---------------------|-------------------|
| **Whisper (—Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—è)** | 2 –≥–æ–ª–æ—Å–æ–≤—ã—Ö –≤ –¥–µ–Ω—å √ó 20 —Å–µ–∫ | $0.006/–º–∏–Ω | ~$24/–º–µ—Å—è—Ü |
| **TTS (–æ–∑–≤—É—á–∫–∞)** | 5 –≤–æ–ø—Ä–æ—Å–æ–≤ –≤ –¥–µ–Ω—å √ó 100 —Å–∏–º–≤–æ–ª–æ–≤ | $15/1M —Å–∏–º–≤–æ–ª–æ–≤ | ~$2.25/–º–µ—Å—è—Ü |
| **ChatGPT (–≥–µ–Ω–µ—Ä–∞—Ü–∏—è)** | 10 –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –º–µ—Å—è—Ü | $0.15/1M —Ç–æ–∫–µ–Ω–æ–≤ | ~$4.50/–º–µ—Å—è—Ü |
| **–ò–¢–û–ì–û** | | | **~$31/–º–µ—Å—è—Ü** |

**–ü—Ä–∏ 10,000 –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:** ~$310/–º–µ—Å—è—Ü
**ROI:** –ï—Å–ª–∏ —Å—Ä–µ–¥–Ω–∏–π —á–µ–∫ –ø–æ–¥–ø–∏—Å–∫–∏ $5/–º–µ—Å—è—Ü, –æ–∫—É–ø–∞–µ—Ç—Å—è —Å 62 –ø–ª–∞—Ç—è—â–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π

---

## üéØ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–ü—Ä–æ–µ–∫—Ç **Vechnost Bot** –∏–º–µ–µ—Ç –æ—Ç–ª–∏—á–Ω—É—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—É—é –æ—Å–Ω–æ–≤—É –∏ –≥–æ—Ç–æ–≤ –∫ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—é. –û—Å–Ω–æ–≤–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:

### –ù–µ–º–µ–¥–ª–µ–Ω–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è (—ç—Ç–∞ –Ω–µ–¥–µ–ª—è)
1. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å OpenAI Whisper –¥–ª—è –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞
2. ‚úÖ –£–ª—É—á—à–∏—Ç—å rate limiting –¥–ª—è –≤—Å–µ—Ö –∫–æ–º–∞–Ω–¥
3. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞

### –ö—Ä–∞—Ç–∫–æ—Å—Ä–æ—á–Ω—ã–µ —Ü–µ–ª–∏ (—ç—Ç–æ—Ç –º–µ—Å—è—Ü)
1. ‚ö†Ô∏è –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å–∏—Å—Ç–µ–º—É –∞–Ω–∞–ª–∏—Ç–∏–∫–∏
2. ‚ö†Ô∏è –î–æ–±–∞–≤–∏—Ç—å TTS –¥–ª—è –æ–∑–≤—É—á–∏–≤–∞–Ω–∏—è –≤–æ–ø—Ä–æ—Å–æ–≤
3. ‚ö†Ô∏è –ù–∞—Å—Ç—Ä–æ–∏—Ç—å Prometheus –º–µ—Ç—Ä–∏–∫–∏

### –î–æ–ª–≥–æ—Å—Ä–æ—á–Ω—ã–µ —Ü–µ–ª–∏ (–∫–≤–∞—Ä—Ç–∞–ª)
1. üìÖ –ì—Ä—É–ø–ø–æ–≤—ã–µ –∏–≥—Ä–æ–≤—ã–µ —Å–µ—Å—Å–∏–∏
2. üìÖ –°–∏—Å—Ç–µ–º–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
3. üìÖ –ö–∞—Å—Ç–æ–º–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–æ–ø—Ä–æ—Å–æ–≤ —á–µ—Ä–µ–∑ GPT

---

**–ê–≤—Ç–æ—Ä –∞–Ω–∞–ª–∏–∑–∞:** AI Assistant with Context7
**–ö–æ–Ω—Ç–∞–∫—Ç:** –î–ª—è –≤–æ–ø—Ä–æ—Å–æ–≤ –æ–±—Ä–∞—â–∞–π—Ç–µ—Å—å –∫ –∫–æ–º–∞–Ω–¥–µ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
**–õ–∏—Ü–µ–Ω–∑–∏—è:** MIT

