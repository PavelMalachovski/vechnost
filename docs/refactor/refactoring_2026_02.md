# ğŸ”„ Vechnost Bot - ĞŸĞ»Ğ°Ğ½ Ñ€ĞµÑ„Ğ°ĞºÑ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³Ğ° Ğ¸ Ñ€Ğ°Ğ·Ğ²Ğ¸Ñ‚Ğ¸Ñ
## Ğ¤ĞµĞ²Ñ€Ğ°Ğ»ÑŒ 2026

**Ğ”Ğ°Ñ‚Ğ° Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ°:** 3 Ñ„ĞµĞ²Ñ€Ğ°Ğ»Ñ 2026  
**Ğ’ĞµÑ€ÑĞ¸Ñ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°:** 1.0.0  
**ĞŸÑ€Ğ¾Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾:** 38 Python Ğ¼Ğ¾Ğ´ÑƒĞ»ĞµĞ¹, 6 YAML Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ², ÑĞ¸ÑÑ‚ĞµĞ¼Ğ° Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ĞµĞ¹, Ğ³Ñ€Ğ°Ñ„Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ñ€ĞµĞ½Ğ´ĞµÑ€Ğ¸Ğ½Ğ³  

---

## ğŸ“Š Ğ¡Ğ¾Ğ´ĞµÑ€Ğ¶Ğ°Ğ½Ğ¸Ğµ

1. [Ğ ĞµĞ·ÑĞ¼Ğµ](#Ñ€ĞµĞ·ÑĞ¼Ğµ)
2. [Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Ğ˜Ğ˜](#-Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ-Ñ-Ğ¸ÑĞºÑƒÑÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğ¼-Ğ¸Ğ½Ñ‚ĞµĞ»Ğ»ĞµĞºÑ‚Ğ¾Ğ¼)
3. [Ğ“Ñ€Ğ°Ñ„Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ñ‡Ğ°ÑÑ‚ÑŒ](#-ÑƒĞ»ÑƒÑ‡ÑˆĞµĞ½Ğ¸Ğµ-Ğ³Ñ€Ğ°Ñ„Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ¹-Ñ‡Ğ°ÑÑ‚Ğ¸)
4. [24-Ñ‡Ğ°ÑĞ¾Ğ²Ğ¾Ğ¹ Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿](#-24-Ñ‡Ğ°ÑĞ¾Ğ²Ğ¾Ğ¹-Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ñ‹Ğ¹-Ğ´Ğ¾ÑÑ‚ÑƒĞ¿)
5. [Ğ˜Ğ³Ñ€Ğ¾Ğ²Ñ‹Ğµ ÑƒĞ»ÑƒÑ‡ÑˆĞµĞ½Ğ¸Ñ](#-Ğ¸Ğ³Ñ€Ğ¾Ğ²Ñ‹Ğµ-ÑƒĞ»ÑƒÑ‡ÑˆĞµĞ½Ğ¸Ñ-Ğ¸-Ğ²Ğ¾Ğ²Ğ»ĞµÑ‡Ñ‘Ğ½Ğ½Ğ¾ÑÑ‚ÑŒ)
6. [ĞœĞ¾Ğ½ĞµÑ‚Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ](#-ÑÑ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ñ-Ğ¼Ğ¾Ğ½ĞµÑ‚Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸)
7. [Ğ¢ĞµÑ…Ğ½Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¿Ğ»Ğ°Ğ½](#-Ñ‚ĞµÑ…Ğ½Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹-Ğ¿Ğ»Ğ°Ğ½-Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸)
8. [ĞŸÑ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ](#-Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ)

---

## Ğ ĞµĞ·ÑĞ¼Ğµ

### Ğ¢ĞµĞºÑƒÑ‰ĞµĞµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°

Vechnost Bot â€” ÑÑ‚Ğ¾ production-ready Telegram Ğ±Ğ¾Ñ‚ Ğ´Ğ»Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡Ğ½Ğ¾Ğ¹ Ğ¸Ğ³Ñ€Ñ‹, Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ğ¾Ğ¹ Ğ½Ğ° ÑƒĞ³Ğ»ÑƒĞ±Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ğ¹. ĞŸÑ€Ğ¾ĞµĞºÑ‚ Ğ¸Ğ¼ĞµĞµÑ‚ **Ğ¾Ñ‚Ğ»Ğ¸Ñ‡Ğ½ÑƒÑ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ½ÑƒÑ Ğ¾ÑĞ½Ğ¾Ğ²Ñƒ**:

| ĞšĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚ | Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ | ĞÑ†ĞµĞ½ĞºĞ° |
|-----------|--------|--------|
| Clean Architecture | âœ… Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ¾ | 9/10 |
| ĞŸĞ»Ğ°Ñ‚ĞµĞ¶Ğ½Ğ°Ñ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ° (Tribute) | âœ… Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ | 8/10 |
| ĞœĞ½Ğ¾Ğ³Ğ¾ÑĞ·Ñ‹Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ (RU/EN/CS) | âœ… ĞŸĞ¾Ğ»Ğ½Ğ°Ñ | 9/10 |
| Ğ ĞµĞ½Ğ´ĞµÑ€Ğ¸Ğ½Ğ³ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞµĞº | âœ… Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ | 6/10 |
| AI Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ | âŒ ĞÑ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ | 0/10 |
| ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° | âš ï¸ ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ°Ñ | 3/10 |
| Ğ“ĞµĞ¹Ğ¼Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ | âŒ ĞÑ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ | 0/10 |

### ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ñ€Ğ°Ğ·Ğ²Ğ¸Ñ‚Ğ¸Ñ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    VECHNOST ROADMAP 2026                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Q1 2026                                                        â”‚
â”‚  â”œâ”€â”€ ğŸ¤– AI Integration (Whisper + GPT)                          â”‚
â”‚  â”œâ”€â”€ ğŸ¨ Enhanced Graphics                                       â”‚
â”‚  â””â”€â”€ ğŸ 24h Free Trial System                                   â”‚
â”‚                                                                 â”‚
â”‚  Q2 2026                                                        â”‚
â”‚  â”œâ”€â”€ ğŸ® Gamification & Achievements                             â”‚
â”‚  â”œâ”€â”€ ğŸ‘¥ Group Sessions                                          â”‚
â”‚  â””â”€â”€ ğŸ“Š Advanced Analytics                                      â”‚
â”‚                                                                 â”‚
â”‚  Q3-Q4 2026                                                     â”‚
â”‚  â”œâ”€â”€ ğŸ’ Premium Features                                        â”‚
â”‚  â”œâ”€â”€ ğŸŒ New Languages                                           â”‚
â”‚  â””â”€â”€ ğŸ“± Mini App Integration                                    â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¤– Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Ğ¸ÑĞºÑƒÑÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğ¼ Ğ¸Ğ½Ñ‚ĞµĞ»Ğ»ĞµĞºÑ‚Ğ¾Ğ¼

### 1. OpenAI Whisper â€” Ğ“Ğ¾Ğ»Ğ¾ÑĞ¾Ğ²Ğ¾Ğ¹ Ğ²Ğ²Ğ¾Ğ´

**ĞŸÑ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚:** ğŸ”´ Ğ’Ğ«Ğ¡ĞĞšĞ˜Ğ™  
**Ğ¡Ğ»Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ:** Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ  
**Ğ’Ñ€ĞµĞ¼Ñ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸:** 3-5 Ğ´Ğ½ĞµĞ¹  
**Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ API:** ~$0.006/Ğ¼Ğ¸Ğ½ÑƒÑ‚Ğ° (~$30/Ğ¼ĞµÑÑÑ† Ğ½Ğ° 1000 Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹)

#### ĞšĞ¾Ğ½Ñ†ĞµĞ¿Ñ†Ğ¸Ñ

ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸ ÑĞ¼Ğ¾Ğ³ÑƒÑ‚ Ğ¾Ñ‚Ğ²ĞµÑ‡Ğ°Ñ‚ÑŒ Ğ½Ğ° Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹ Ğ³Ğ¾Ğ»Ğ¾ÑĞ¾Ğ¼, Ñ‡Ñ‚Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ñ‘Ñ‚ Ğ±Ğ¾Ğ»ĞµĞµ Ğ¸Ğ½Ñ‚Ğ¸Ğ¼Ğ½ÑƒÑ Ğ¸ ĞµÑÑ‚ĞµÑÑ‚Ğ²ĞµĞ½Ğ½ÑƒÑ Ğ°Ñ‚Ğ¼Ğ¾ÑÑ„ĞµÑ€Ñƒ Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ. ĞÑĞ¾Ğ±ĞµĞ½Ğ½Ğ¾ Ñ†ĞµĞ½Ğ½Ğ¾ Ğ´Ğ»Ñ Ñ‚ĞµĞ¼ "Ğ”Ğ»Ñ Ğ¿Ğ°Ñ€" Ğ¸ "Ğ¡ĞµĞºÑ", Ğ³Ğ´Ğµ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ğ²Ğ²Ğ¾Ğ´ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ğ½ĞµĞ»Ğ¾Ğ²ĞºĞ¸Ğ¼.

#### ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Telegram      â”‚â”€â”€â”€â”€â–¶â”‚  Voice Handler   â”‚â”€â”€â”€â”€â–¶â”‚  OpenAI        â”‚
â”‚   Voice Msg     â”‚     â”‚  (download .ogg) â”‚     â”‚  Whisper API   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                          â”‚
                                                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Response      â”‚â—€â”€â”€â”€â”€â”‚  Session State   â”‚â—€â”€â”€â”€â”€â”‚  Transcribed   â”‚
â”‚   to User       â”‚     â”‚  Update          â”‚     â”‚  Text          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ

```python
# vechnost_bot/ai/whisper_service.py
"""Voice transcription service using OpenAI Whisper API."""

import logging
from pathlib import Path
from typing import Optional
import aiofiles
from openai import AsyncOpenAI

from ..config import settings
from ..i18n import Language
from ..monitoring import track_performance, log_bot_event

logger = logging.getLogger(__name__)


class WhisperService:
    """Service for transcribing voice messages using OpenAI Whisper."""

    # Language mapping for Whisper API
    LANGUAGE_MAP = {
        Language.RUSSIAN: "ru",
        Language.ENGLISH: "en",
        Language.CZECH: "cs",
    }

    def __init__(self):
        self.client = AsyncOpenAI(api_key=settings.openai_api_key)
        self.temp_dir = Path("temp/voice")
        self.temp_dir.mkdir(parents=True, exist_ok=True)

    @track_performance("transcribe_voice")
    async def transcribe(
        self,
        audio_data: bytes,
        language: Language,
        user_id: int,
    ) -> Optional[str]:
        """
        Transcribe audio bytes to text.

        Args:
            audio_data: Raw audio bytes (OGG format from Telegram)
            language: Preferred language for transcription
            user_id: User ID for logging

        Returns:
            Transcribed text or None if error
        """
        try:
            transcription = await self.client.audio.transcriptions.create(
                model="whisper-1",
                file=("audio.ogg", audio_data, "audio/ogg"),
                response_format="verbose_json",
                language=self.LANGUAGE_MAP.get(language, "ru"),
                temperature=0.0,  # More deterministic output
            )

            text = transcription.text.strip()
            
            log_bot_event(
                "voice_transcribed",
                user_id=user_id,
                text_length=len(text),
                detected_language=transcription.language,
                duration=transcription.duration,
            )

            logger.info(
                f"Voice transcribed for user {user_id}: "
                f"{len(text)} chars, {transcription.duration:.1f}s"
            )

            return text

        except Exception as e:
            logger.error(f"Whisper transcription error: {e}", exc_info=True)
            log_bot_event("voice_transcription_error", user_id=user_id, error=str(e))
            return None


# Singleton instance
whisper_service = WhisperService()
```

#### Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Ñ…ĞµĞ½Ğ´Ğ»ĞµÑ€Ğ°Ğ¼Ğ¸

```python
# vechnost_bot/handlers.py â€” Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ³Ğ¾Ğ»Ğ¾ÑĞ¾Ğ²Ñ‹Ñ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹

from telegram import Update
from telegram.ext import ContextTypes, MessageHandler, filters

from .ai.whisper_service import whisper_service


async def handle_voice_message(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE
) -> None:
    """Handle incoming voice messages."""
    if not update.message or not update.message.voice:
        return

    chat_id = update.effective_chat.id
    user_id = update.effective_user.id

    # Get session for language preference
    session = await get_session(chat_id)
    language = session.language

    # Show typing indicator
    await context.bot.send_chat_action(chat_id=chat_id, action="typing")

    # Download voice file
    voice = update.message.voice
    voice_file = await context.bot.get_file(voice.file_id)
    audio_bytes = await voice_file.download_as_bytearray()

    # Transcribe
    text = await whisper_service.transcribe(
        audio_data=bytes(audio_bytes),
        language=language,
        user_id=user_id,
    )

    if text:
        response = get_text("voice.transcribed", language).format(text=text)
        await update.message.reply_text(response, parse_mode="HTML")
    else:
        error_msg = get_text("voice.error", language)
        await update.message.reply_text(error_msg)


# Register in bot.py:
# application.add_handler(MessageHandler(filters.VOICE, handle_voice_message))
```

#### ĞŸĞµÑ€ĞµĞ²Ğ¾Ğ´Ñ‹

```yaml
# data/translations_ru.yaml
voice:
  processing: "ğŸ¤ Ğ Ğ°ÑĞ¿Ğ¾Ğ·Ğ½Ğ°Ñ Ğ³Ğ¾Ğ»Ğ¾ÑĞ¾Ğ²Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ..."
  transcribed: "ğŸ“ <b>Ğ’Ñ‹ ÑĞºĞ°Ğ·Ğ°Ğ»Ğ¸:</b>\n\n<i>{text}</i>"
  error: "âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ñ€Ğ°ÑĞ¿Ğ¾Ğ·Ğ½Ğ°Ñ‚ÑŒ Ğ³Ğ¾Ğ»Ğ¾Ñ. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ· Ğ¸Ğ»Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ¼."
  too_long: "â±ï¸ Ğ“Ğ¾Ğ»Ğ¾ÑĞ¾Ğ²Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ´Ğ»Ğ¸Ğ½Ğ½Ğ¾Ğµ (Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 2 Ğ¼Ğ¸Ğ½ÑƒÑ‚Ñ‹)"

# data/translations_en.yaml  
voice:
  processing: "ğŸ¤ Transcribing voice message..."
  transcribed: "ğŸ“ <b>You said:</b>\n\n<i>{text}</i>"
  error: "âŒ Failed to transcribe. Please try again or send as text."
  too_long: "â±ï¸ Voice message too long (max 2 minutes)"

# data/translations_cs.yaml
voice:
  processing: "ğŸ¤ PÅ™episuji hlasovou zprÃ¡vu..."
  transcribed: "ğŸ“ <b>Å˜ekli jste:</b>\n\n<i>{text}</i>"
  error: "âŒ NepodaÅ™ilo se pÅ™epsat. Zkuste znovu nebo poÅ¡lete text."
  too_long: "â±ï¸ HlasovÃ¡ zprÃ¡va je pÅ™Ã­liÅ¡ dlouhÃ¡ (max 2 minuty)"
```

---

### 2. ChatGPT â€” ĞŸĞµÑ€ÑĞ¾Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹

**ĞŸÑ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚:** ğŸŸ¡ Ğ¡Ğ Ğ•Ğ”ĞĞ˜Ğ™  
**Ğ¡Ğ»Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ:** Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ  
**Ğ’Ñ€ĞµĞ¼Ñ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸:** 5-7 Ğ´Ğ½ĞµĞ¹  
**Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ API:** ~$0.15/1M Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ² (~$5/Ğ¼ĞµÑÑÑ† Ğ½Ğ° 1000 Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹)

#### ĞšĞ¾Ğ½Ñ†ĞµĞ¿Ñ†Ğ¸Ñ

AI Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿ĞµÑ€ÑĞ¾Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹ Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğµ:
- ĞšĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ğ° Ğ¿Ğ°Ñ€Ñ‹ (Ğ´Ğ°Ğ²Ğ½Ğ¾ Ğ²Ğ¼ĞµÑÑ‚Ğµ / Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ğ¾Ğ·Ğ½Ğ°ĞºĞ¾Ğ¼Ğ¸Ğ»Ğ¸ÑÑŒ)
- ĞŸÑ€ĞµĞ´Ğ¿Ğ¾Ñ‡Ñ‚ĞµĞ½Ğ¸Ğ¹ Ğ¸ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸ Ğ¸Ğ³Ñ€Ñ‹
- Ğ¡Ğ¿ĞµÑ†Ğ¸Ñ„Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ² Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ

#### ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°

```python
# vechnost_bot/ai/question_generator.py
"""AI-powered custom question generator."""

from typing import Optional
from openai import AsyncOpenAI

from ..config import settings
from ..i18n import Language
from ..models import Theme


class QuestionGenerator:
    """Generate personalized questions using GPT-4o-mini."""

    SYSTEM_PROMPTS = {
        Language.RUSSIAN: """Ğ¢Ñ‹ â€” ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ĞµĞ»ÑŒ Ğ³Ğ»ÑƒĞ±Ğ¾ĞºĞ¸Ñ… Ğ¸ Ğ¸Ğ½Ñ‚Ğ¸Ğ¼Ğ½Ñ‹Ñ… Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¾Ğ² Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€. 
Ğ¢Ğ²Ğ¾Ñ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ° â€” Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ:
- ĞŸĞ¾Ğ¼Ğ¾Ğ³Ğ°ÑÑ‚ Ğ¿Ğ°Ñ€Ñ‚Ğ½Ñ‘Ñ€Ğ°Ğ¼ ÑƒĞ·Ğ½Ğ°Ñ‚ÑŒ Ğ´Ñ€ÑƒĞ³ Ğ´Ñ€ÑƒĞ³Ğ° Ğ³Ğ»ÑƒĞ±Ğ¶Ğµ
- Ğ¡Ğ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ÑƒÑÑ‚ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ½Ğ¾Ğ¼Ñƒ ÑƒÑ€Ğ¾Ğ²Ğ½Ñ Ğ¸Ğ½Ñ‚Ğ¸Ğ¼Ğ½Ğ¾ÑÑ‚Ğ¸
- Ğ’Ñ‹Ğ·Ñ‹Ğ²Ğ°ÑÑ‚ Ğ¸ÑĞºÑ€ĞµĞ½Ğ½Ğ¸Ğµ Ğ¸ Ñ‡ĞµÑÑ‚Ğ½Ñ‹Ğµ Ñ€Ğ°Ğ·Ğ³Ğ¾Ğ²Ğ¾Ñ€Ñ‹
- ĞĞ• ÑĞ²Ğ»ÑÑÑ‚ÑÑ ĞºĞ»Ğ¸ÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ¸Ğ»Ğ¸ Ğ±Ğ°Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¼Ğ¸

Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°: Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹, ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ¾ĞºĞ¸, Ğ±ĞµĞ· Ğ½ÑƒĞ¼ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸.""",

        Language.ENGLISH: """You are a creator of deep and intimate questions for couples.
Your task is to generate questions that:
- Help partners know each other deeper
- Match the specified intimacy level
- Spark sincere and honest conversations
- Are NOT clichÃ©d or banal

Response format: questions only, one per line, no numbering.""",

        Language.CZECH: """Jsi tvÅ¯rce hlubokÃ½ch a intimnÃ­ch otÃ¡zek pro pÃ¡ry.
TvÃ½m Ãºkolem je generovat otÃ¡zky, kterÃ©:
- Pomohou partnerÅ¯m lÃ©pe se poznat
- OdpovÃ­dajÃ­ uvedenÃ© Ãºrovni intimity
- VyvolÃ¡vajÃ­ upÅ™Ã­mnÃ© a ÄestnÃ© rozhovory
- NEJSOU kliÅ¡Ã© nebo banÃ¡lnÃ­

FormÃ¡t odpovÄ›di: pouze otÃ¡zky, kaÅ¾dÃ¡ na novÃ©m Å™Ã¡dku, bez ÄÃ­slovÃ¡nÃ­.""",
    }

    THEME_CONTEXTS = {
        Theme.ACQUAINTANCE: "Ğ¿ĞµÑ€Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°ĞºĞ¾Ğ¼ÑÑ‚Ğ²Ğ¾, Ğ»Ñ‘Ğ³ĞºĞ¸Ğ¹ Ñ„Ğ»Ğ¸Ñ€Ñ‚, ÑƒĞ·Ğ½Ğ°Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞºĞ°",
        Theme.FOR_COUPLES: "Ğ³Ğ»ÑƒĞ±Ğ¾ĞºĞ¸Ğµ Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ñ, Ğ¾Ğ±Ñ‰Ğ¸Ğµ Ñ†ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸, Ğ±ÑƒĞ´ÑƒÑ‰ĞµĞµ Ğ²Ğ¼ĞµÑÑ‚Ğµ",
        Theme.SEX: "Ğ¸Ğ½Ñ‚Ğ¸Ğ¼Ğ½Ğ°Ñ Ğ±Ğ»Ğ¸Ğ·Ğ¾ÑÑ‚ÑŒ, Ğ¶ĞµĞ»Ğ°Ğ½Ğ¸Ñ, Ñ„Ğ°Ğ½Ñ‚Ğ°Ğ·Ğ¸Ğ¸, ÑĞµĞºÑÑƒĞ°Ğ»ÑŒĞ½Ğ°Ñ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ",
        Theme.PROVOCATION: "Ğ¿Ñ€Ğ¾Ğ²Ğ¾ĞºĞ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğµ Ñ‚ĞµĞ¼Ñ‹, ÑĞ»Ğ¾Ğ¶Ğ½Ñ‹Ğµ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ñ‹, Ğ¼Ğ¾Ñ€Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ´Ğ¸Ğ»ĞµĞ¼Ğ¼Ñ‹",
    }

    def __init__(self):
        self.client = AsyncOpenAI(api_key=settings.openai_api_key)

    async def generate_questions(
        self,
        theme: Theme,
        level: int,
        language: Language,
        context: Optional[str] = None,
        count: int = 5,
    ) -> list[str]:
        """
        Generate personalized questions.

        Args:
            theme: Game theme
            level: Intimacy level (1-3)
            language: Target language
            context: Optional user context (e.g., "together 5 years")
            count: Number of questions to generate

        Returns:
            List of generated questions
        """
        theme_context = self.THEME_CONTEXTS.get(theme, "Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ¿Ğ°Ñ€Ñ‚Ğ½Ñ‘Ñ€Ğ°Ğ¼Ğ¸")
        
        user_prompt = f"""Ğ¡Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞ¹ {count} ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¾Ğ².

Ğ¢ĞµĞ¼Ğ°: {theme.value}
ĞšĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚ Ñ‚ĞµĞ¼Ñ‹: {theme_context}
Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ Ğ¸Ğ½Ñ‚Ğ¸Ğ¼Ğ½Ğ¾ÑÑ‚Ğ¸: {level}/3 (Ğ³Ğ´Ğµ 1 â€” Ğ»ĞµĞ³ĞºĞ¸Ğ¹, 3 â€” Ğ³Ğ»ÑƒĞ±Ğ¾ĞºĞ¸Ğ¹)
"""
        if context:
            user_prompt += f"\nĞšĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚ Ğ¿Ğ°Ñ€Ñ‹: {context}"

        response = await self.client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": self.SYSTEM_PROMPTS[language]},
                {"role": "user", "content": user_prompt},
            ],
            temperature=0.9,  # Higher creativity
            max_tokens=1000,
        )

        content = response.choices[0].message.content
        questions = [
            q.strip().lstrip("0123456789.-) ")
            for q in content.split("\n")
            if q.strip() and len(q.strip()) > 10
        ]

        return questions[:count]


# Singleton
question_generator = QuestionGenerator()
```

#### UI Ğ´Ğ»Ñ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸

```python
# Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ² keyboards.py

def get_ai_question_keyboard(language: Language) -> InlineKeyboardMarkup:
    """Get keyboard for AI question generation."""
    keyboard = [
        [InlineKeyboardButton(
            "âœ¨ " + get_text('ai.generate_question', language),
            callback_data="ai:generate"
        )],
        [InlineKeyboardButton(
            get_text('navigation.back', language),
            callback_data="back:themes"
        )],
    ]
    return InlineKeyboardMarkup(keyboard)
```

---

### 3. OpenAI TTS â€” ĞĞ·Ğ²ÑƒÑ‡Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²

**ĞŸÑ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚:** ğŸŸ¢ ĞĞ˜Ğ—ĞšĞ˜Ğ™  
**Ğ¡Ğ»Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ:** ĞĞ¸Ğ·ĞºĞ°Ñ  
**Ğ’Ñ€ĞµĞ¼Ñ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸:** 2-3 Ğ´Ğ½Ñ  
**Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ API:** ~$15/1M ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ² (~$3/Ğ¼ĞµÑÑÑ† Ğ½Ğ° 1000 Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹)

#### ĞšĞ¾Ğ½Ñ†ĞµĞ¿Ñ†Ğ¸Ñ

Ğ’Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹ Ğ¸Ğ· ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞµĞº Ğ¾Ğ·Ğ²ÑƒÑ‡Ğ¸Ğ²Ğ°ÑÑ‚ÑÑ Ğ³Ğ¾Ğ»Ğ¾ÑĞ¾Ğ¼, ÑĞ¾Ğ·Ğ´Ğ°Ğ²Ğ°Ñ Ğ°Ñ‚Ğ¼Ğ¾ÑÑ„ĞµÑ€Ñƒ "Ğ¸Ğ³Ñ€Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ¼Ğ°ÑÑ‚ĞµÑ€Ğ°". ĞÑĞ¾Ğ±ĞµĞ½Ğ½Ğ¾ Ğ¿Ğ¾Ğ»ĞµĞ·Ğ½Ğ¾ Ğ´Ğ»Ñ:
- Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ°Ñ‚Ğ¼Ğ¾ÑÑ„ĞµÑ€Ñ‹
- ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ñ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸ÑĞ¼Ğ¸ Ğ·Ñ€ĞµĞ½Ğ¸Ñ
- Ğ˜Ğ³Ñ€Ñ‹ Ğ² Ñ‚ĞµĞ¼Ğ½Ğ¾Ñ‚Ğµ / Ñ€Ğ¾Ğ¼Ğ°Ğ½Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ¹ Ğ¾Ğ±ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞµ

```python
# vechnost_bot/ai/tts_service.py
"""Text-to-Speech service using OpenAI TTS API."""

import hashlib
from pathlib import Path
from typing import Optional
from openai import AsyncOpenAI

from ..config import settings
from ..i18n import Language


class TTSService:
    """Convert text to speech with caching."""

    VOICE_MAP = {
        Language.RUSSIAN: "nova",   # Soft female voice
        Language.ENGLISH: "alloy",  # Neutral voice
        Language.CZECH: "shimmer",  # Warm female voice
    }

    def __init__(self):
        self.client = AsyncOpenAI(api_key=settings.openai_api_key)
        self.cache_dir = Path("cache/tts")
        self.cache_dir.mkdir(parents=True, exist_ok=True)

    def _cache_key(self, text: str, language: Language) -> str:
        """Generate cache key for audio."""
        content = f"{text}:{language.value}".encode('utf-8')
        return hashlib.sha256(content).hexdigest()[:16]

    async def text_to_speech(
        self,
        text: str,
        language: Language,
    ) -> Optional[Path]:
        """
        Convert text to speech audio file.

        Args:
            text: Text to convert
            language: Voice language

        Returns:
            Path to MP3 file or None if error
        """
        cache_key = self._cache_key(text, language)
        cache_path = self.cache_dir / f"{cache_key}.mp3"

        # Return cached if exists
        if cache_path.exists():
            return cache_path

        try:
            voice = self.VOICE_MAP.get(language, "nova")
            
            response = await self.client.audio.speech.create(
                model="tts-1",
                voice=voice,
                input=text[:4096],  # API limit
                response_format="mp3",
            )

            response.stream_to_file(cache_path)
            return cache_path

        except Exception as e:
            logger.error(f"TTS error: {e}")
            return None


tts_service = TTSService()
```

---

## ğŸ¨ Ğ£Ğ»ÑƒÑ‡ÑˆĞµĞ½Ğ¸Ğµ Ğ³Ñ€Ğ°Ñ„Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ¹ Ñ‡Ğ°ÑÑ‚Ğ¸

### Ğ¢ĞµĞºÑƒÑ‰ĞµĞµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ

Ğ ĞµĞ½Ğ´ĞµÑ€Ğ¸Ğ½Ğ³ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞµĞº (`renderer.py`) Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚:
- PIL/Pillow Ğ´Ğ»Ñ Ñ€ĞµĞ½Ğ´ĞµÑ€Ğ¸Ğ½Ğ³Ğ°
- Ğ¤Ğ¸ĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ 1080x1350
- ĞĞ´Ğ¸Ğ½ ÑˆÑ€Ğ¸Ñ„Ñ‚ (DejaVuSans, 53px)
- Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ Ñ„Ğ¾Ğ½Ñ‹ Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¹ Ñ‚ĞµĞ¼Ñ‹

### ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹

1. **ĞĞ´Ğ½Ğ¾Ğ¾Ğ±Ñ€Ğ°Ğ·Ğ½Ñ‹Ğ¹ Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½** â€” Ğ²ÑĞµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ²Ñ‹Ğ³Ğ»ÑĞ´ÑÑ‚ Ğ¾Ğ´Ğ¸Ğ½Ğ°ĞºĞ¾Ğ²Ğ¾
2. **ĞĞµÑ‚ Ğ°Ğ´Ğ°Ğ¿Ñ‚Ğ°Ñ†Ğ¸Ğ¸ Ñ‚ĞµĞºÑÑ‚Ğ°** â€” Ğ´Ğ»Ğ¸Ğ½Ğ½Ñ‹Ğµ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹ Ğ¿Ğ»Ğ¾Ñ…Ğ¾ Ñ‡Ğ¸Ñ‚Ğ°ÑÑ‚ÑÑ
3. **ĞÑ‚ÑÑƒÑ‚ÑÑ‚Ğ²Ğ¸Ğµ Ğ°Ğ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ğ¹** â€” ÑÑ‚Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ
4. **ĞĞµÑ‚ Ğ±Ñ€ĞµĞ½Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ** â€” Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ»Ğ¾Ğ³Ğ¾Ñ‚Ğ¸Ğ¿ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ°Ñ…

### ĞŸĞ»Ğ°Ğ½ ÑƒĞ»ÑƒÑ‡ÑˆĞµĞ½Ğ¸Ğ¹

#### 1. Ğ”Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞµĞº

```python
# vechnost_bot/renderer_v2.py
"""Enhanced card renderer with dynamic design."""

from dataclasses import dataclass
from PIL import Image, ImageDraw, ImageFont, ImageFilter
from io import BytesIO
from typing import Optional
import colorsys


@dataclass
class CardStyle:
    """Style configuration for card rendering."""
    primary_color: tuple[int, int, int]
    secondary_color: tuple[int, int, int]
    text_color: tuple[int, int, int]
    font_family: str
    corner_radius: int = 40
    shadow_blur: int = 20
    gradient_angle: int = 135


class ThemeStyles:
    """Theme-specific styles."""
    
    ACQUAINTANCE = CardStyle(
        primary_color=(255, 215, 0),    # Gold
        secondary_color=(255, 193, 7),  # Amber
        text_color=(33, 33, 33),        # Dark gray
        font_family="Montserrat-Medium",
    )
    
    FOR_COUPLES = CardStyle(
        primary_color=(233, 30, 99),    # Pink
        secondary_color=(156, 39, 176), # Purple
        text_color=(255, 255, 255),     # White
        font_family="Playfair-Regular",
    )
    
    SEX = CardStyle(
        primary_color=(244, 67, 54),    # Red
        secondary_color=(183, 28, 28),  # Dark red
        text_color=(255, 255, 255),     # White
        font_family="Roboto-Bold",
    )
    
    PROVOCATION = CardStyle(
        primary_color=(103, 58, 183),   # Deep purple
        secondary_color=(63, 81, 181),  # Indigo
        text_color=(255, 255, 255),     # White
        font_family="Oswald-Regular",
    )


class EnhancedRenderer:
    """Enhanced card renderer with modern design."""

    def __init__(self):
        self.width = 1080
        self.height = 1350
        self.logo_path = Path("assets/images/vechnost_logo.png")

    def _create_gradient_background(
        self,
        style: CardStyle,
        level: int,
    ) -> Image.Image:
        """Create gradient background based on theme and level."""
        img = Image.new('RGB', (self.width, self.height))
        draw = ImageDraw.Draw(img)

        # Adjust colors based on level (darker = deeper level)
        factor = 1 - (level - 1) * 0.15
        
        def adjust_brightness(color: tuple, f: float) -> tuple:
            return tuple(int(c * f) for c in color)

        c1 = adjust_brightness(style.primary_color, factor)
        c2 = adjust_brightness(style.secondary_color, factor)

        # Create smooth gradient
        for y in range(self.height):
            ratio = y / self.height
            r = int(c1[0] * (1 - ratio) + c2[0] * ratio)
            g = int(c1[1] * (1 - ratio) + c2[1] * ratio)
            b = int(c1[2] * (1 - ratio) + c2[2] * ratio)
            draw.line([(0, y), (self.width, y)], fill=(r, g, b))

        return img

    def _add_decorative_elements(
        self,
        img: Image.Image,
        style: CardStyle,
        question_number: int,
    ) -> Image.Image:
        """Add decorative elements to the card."""
        draw = ImageDraw.Draw(img)

        # Add subtle pattern overlay
        # Add corner decorations
        # Add question number badge
        
        # Number badge in top-right
        badge_size = 80
        badge_x = self.width - badge_size - 40
        badge_y = 40
        
        draw.ellipse(
            [badge_x, badge_y, badge_x + badge_size, badge_y + badge_size],
            fill=(255, 255, 255, 180)
        )
        
        # Draw number
        font = ImageFont.truetype("assets/fonts/Montserrat-Bold.ttf", 36)
        number_text = str(question_number)
        bbox = font.getbbox(number_text)
        text_x = badge_x + (badge_size - (bbox[2] - bbox[0])) // 2
        text_y = badge_y + (badge_size - (bbox[3] - bbox[1])) // 2
        draw.text((text_x, text_y), number_text, fill=style.primary_color, font=font)

        return img

    def _add_logo_watermark(self, img: Image.Image) -> Image.Image:
        """Add subtle logo watermark."""
        if not self.logo_path.exists():
            return img

        logo = Image.open(self.logo_path).convert('RGBA')
        
        # Scale logo to 100px width
        ratio = 100 / logo.width
        logo = logo.resize(
            (100, int(logo.height * ratio)),
            Image.Resampling.LANCZOS
        )

        # Make semi-transparent
        logo.putalpha(int(255 * 0.3))

        # Position in bottom-right
        x = self.width - logo.width - 30
        y = self.height - logo.height - 30

        img.paste(logo, (x, y), logo)
        return img

    def render_card(
        self,
        text: str,
        theme: str,
        level: int,
        question_number: int,
        total_questions: int,
    ) -> BytesIO:
        """
        Render a question card with enhanced design.

        Args:
            text: Question text
            theme: Theme name
            level: Level number (1-3)
            question_number: Current question number
            total_questions: Total questions in category

        Returns:
            BytesIO with JPEG image data
        """
        # Get theme style
        style_map = {
            "Acquaintance": ThemeStyles.ACQUAINTANCE,
            "For Couples": ThemeStyles.FOR_COUPLES,
            "Sex": ThemeStyles.SEX,
            "Provocation": ThemeStyles.PROVOCATION,
        }
        style = style_map.get(theme, ThemeStyles.ACQUAINTANCE)

        # Create base image
        img = self._create_gradient_background(style, level)
        img = self._add_decorative_elements(img, style, question_number)
        
        # Add text
        img = self._render_text(img, text, style)
        
        # Add watermark
        img = self._add_logo_watermark(img)

        # Export
        output = BytesIO()
        img.save(output, format='JPEG', quality=92, optimize=True)
        output.seek(0)
        return output
```

#### 2. ĞĞ½Ğ¸Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸ (GIF)

```python
# vechnost_bot/animated_renderer.py
"""Animated card renderer for special effects."""

from PIL import Image
from io import BytesIO


class AnimatedRenderer:
    """Create animated GIF cards for special moments."""

    def render_reveal_animation(
        self,
        question: str,
        theme: str,
        frames: int = 15,
        duration: int = 50,  # ms per frame
    ) -> BytesIO:
        """
        Create card reveal animation.
        
        The card appears to flip/reveal from blank to question.
        """
        images = []
        
        for i in range(frames):
            progress = i / (frames - 1)  # 0.0 to 1.0
            
            # First half: show back of card
            if progress < 0.5:
                img = self._render_card_back(theme, progress * 2)
            else:
                # Second half: reveal question with fade-in
                opacity = (progress - 0.5) * 2
                img = self._render_card_front(question, theme, opacity)
            
            images.append(img)

        output = BytesIO()
        images[0].save(
            output,
            format='GIF',
            save_all=True,
            append_images=images[1:],
            duration=duration,
            loop=0,
        )
        output.seek(0)
        return output
```

#### 3. Responsive Ñ‚ĞµĞºÑÑ‚

```python
def _calculate_optimal_font_size(
    self,
    text: str,
    max_width: int,
    max_height: int,
    min_size: int = 32,
    max_size: int = 64,
) -> tuple[ImageFont.FreeTypeFont, int]:
    """
    Calculate optimal font size for text to fit in bounds.
    
    Returns:
        (font, optimal_size)
    """
    for size in range(max_size, min_size - 1, -2):
        font = ImageFont.truetype(self.font_path, size)
        lines = self._wrap_text(text, font, max_width)
        
        total_height = sum(
            font.getbbox(line)[3] - font.getbbox(line)[1]
            for line in lines
        ) + (len(lines) - 1) * int(size * 0.4)  # line spacing
        
        if total_height <= max_height:
            return font, size
    
    return ImageFont.truetype(self.font_path, min_size), min_size
```

---

## ğŸ 24-Ñ‡Ğ°ÑĞ¾Ğ²Ğ¾Ğ¹ Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿

### ĞšĞ¾Ğ½Ñ†ĞµĞ¿Ñ†Ğ¸Ñ

Ğ”Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼ **Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğ½Ğ° 24 Ñ‡Ğ°ÑĞ°** Ğ±ĞµĞ· Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹. Ğ­Ñ‚Ğ¾ Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»Ğ¸Ñ‚:
- ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²ÑĞµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ¸Ğ³Ñ€Ñ‹
- Ğ¡Ñ„Ğ¾Ñ€Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¸Ğ²Ñ‹Ñ‡ĞºÑƒ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
- ĞŸÑ€Ğ¸Ğ½ÑÑ‚ÑŒ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ Ğ¾ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞµ Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğµ Ğ¾Ğ¿Ñ‹Ñ‚Ğ°

### ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   New User      â”‚â”€â”€â”€â”€â–¶â”‚  Create Trial    â”‚â”€â”€â”€â”€â–¶â”‚  trial_access   â”‚
â”‚   /start        â”‚     â”‚  Session         â”‚     â”‚  table in DB    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                          â”‚
                                                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   24h Passed    â”‚â—€â”€â”€â”€â”€â”‚  Middleware      â”‚â—€â”€â”€â”€â”€â”‚  Check expiry   â”‚
â”‚   Show Paywall  â”‚     â”‚  Check Access    â”‚     â”‚  on each cmd    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ

#### ĞœĞ¾Ğ´ĞµĞ»ÑŒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…

```python
# vechnost_bot/payments/models.py â€” Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¼Ğ¾Ğ´ĞµĞ»ÑŒ

class TrialAccess(Base):
    """Model for tracking free trial access."""

    __tablename__ = "trial_access"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    telegram_user_id: Mapped[int] = mapped_column(
        BigInteger, unique=True, nullable=False
    )
    started_at: Mapped[datetime] = mapped_column(
        default=datetime.utcnow, nullable=False
    )
    expires_at: Mapped[datetime] = mapped_column(nullable=False)
    converted_to_paid: Mapped[bool] = mapped_column(default=False, nullable=False)
    reminder_sent: Mapped[bool] = mapped_column(default=False, nullable=False)

    __table_args__ = (
        Index("idx_trial_telegram_user", "telegram_user_id"),
        Index("idx_trial_expires", "expires_at"),
    )

    @property
    def is_active(self) -> bool:
        """Check if trial is still active."""
        return datetime.utcnow() < self.expires_at

    @property
    def hours_remaining(self) -> int:
        """Get hours remaining in trial."""
        if not self.is_active:
            return 0
        delta = self.expires_at - datetime.utcnow()
        return int(delta.total_seconds() / 3600)
```

#### Ğ¡ĞµÑ€Ğ²Ğ¸Ñ Ñ‚Ñ€Ğ¸Ğ°Ğ»Ğ°

```python
# vechnost_bot/payments/trial_service.py
"""Service for managing free trial access."""

from datetime import datetime, timedelta
from typing import Optional
import logging

from .database import get_db
from .models import TrialAccess
from .repositories import TrialRepository

logger = logging.getLogger(__name__)

TRIAL_DURATION_HOURS = 24


class TrialService:
    """Service for free trial management."""

    @staticmethod
    async def start_trial(telegram_user_id: int) -> TrialAccess:
        """
        Start a new trial for user.
        
        Args:
            telegram_user_id: Telegram user ID
            
        Returns:
            TrialAccess instance
        """
        async with get_db() as session:
            # Check if trial already exists
            existing = await TrialRepository.get_by_telegram_id(
                session, telegram_user_id
            )
            
            if existing:
                logger.info(
                    f"User {telegram_user_id} already has trial "
                    f"(expires: {existing.expires_at})"
                )
                return existing
            
            # Create new trial
            trial = await TrialRepository.create(
                session,
                telegram_user_id=telegram_user_id,
                expires_at=datetime.utcnow() + timedelta(hours=TRIAL_DURATION_HOURS),
            )
            
            logger.info(
                f"Trial started for user {telegram_user_id}, "
                f"expires at {trial.expires_at}"
            )
            
            return trial

    @staticmethod
    async def check_trial_access(telegram_user_id: int) -> tuple[bool, Optional[int]]:
        """
        Check if user has active trial access.
        
        Returns:
            (has_access, hours_remaining)
        """
        async with get_db() as session:
            trial = await TrialRepository.get_by_telegram_id(
                session, telegram_user_id
            )
            
            if not trial:
                return False, None
            
            if trial.is_active:
                return True, trial.hours_remaining
            
            return False, 0

    @staticmethod
    async def send_expiration_reminder(telegram_user_id: int) -> bool:
        """
        Mark reminder as sent for expiring trial.
        
        Returns:
            True if reminder should be sent (wasn't sent before)
        """
        async with get_db() as session:
            trial = await TrialRepository.get_by_telegram_id(
                session, telegram_user_id
            )
            
            if not trial or trial.reminder_sent:
                return False
            
            # Check if 2 hours remaining
            if trial.hours_remaining <= 2 and trial.hours_remaining > 0:
                await TrialRepository.mark_reminder_sent(session, trial)
                return True
            
            return False


trial_service = TrialService()
```

#### Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ğ² middleware

```python
# vechnost_bot/payments/middleware.py â€” Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ

async def check_payment_or_trial(telegram_user_id: int) -> tuple[bool, str]:
    """
    Check if user has paid access OR active trial.
    
    Returns:
        (has_access, access_type)  # access_type: "paid", "trial", "none"
    """
    # Check paid access first
    if await user_has_access(telegram_user_id):
        return True, "paid"
    
    # Check trial access
    has_trial, hours_left = await trial_service.check_trial_access(telegram_user_id)
    if has_trial:
        return True, "trial"
    
    return False, "none"
```

#### UI Ğ´Ğ»Ñ Ñ‚Ñ€Ğ¸Ğ°Ğ»Ğ°

```python
# ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ñ‚Ñ€Ğ¸Ğ°Ğ»Ğ° Ğ² welcome message

async def show_trial_status(
    update: Update,
    trial: TrialAccess,
    language: Language,
) -> None:
    """Show trial status banner."""
    hours = trial.hours_remaining
    
    if hours > 6:
        emoji = "ğŸ"
        urgency = ""
    elif hours > 2:
        emoji = "â°"
        urgency = get_text("trial.ending_soon", language)
    else:
        emoji = "âš ï¸"
        urgency = get_text("trial.ending_very_soon", language)
    
    status_text = get_text("trial.status", language).format(
        emoji=emoji,
        hours=hours,
        urgency=urgency,
    )
    
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton(
            get_text("trial.upgrade_now", language),
            url=settings.tribute_payment_url
        )]
    ])
    
    await update.message.reply_text(
        status_text,
        reply_markup=keyboard,
        parse_mode="HTML",
    )
```

#### ĞŸĞµÑ€ĞµĞ²Ğ¾Ğ´Ñ‹

```yaml
# data/translations_ru.yaml
trial:
  welcome: |
    ğŸ <b>Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ!</b>
    
    Ğ£ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ <b>24 Ñ‡Ğ°ÑĞ° Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°</b> ĞºĞ¾ Ğ²ÑĞµĞ¼ Ñ„ÑƒĞ½ĞºÑ†Ğ¸ÑĞ¼ Ğ¸Ğ³Ñ€Ñ‹.
    
    Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ÑÑ‚Ğ¾ Ğ²Ñ€ĞµĞ¼Ñ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¸ÑÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²ÑĞµ Ñ‚ĞµĞ¼Ñ‹ Ğ¸ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ ÑĞ²Ğ¾Ñ Ğ»ÑĞ±Ğ¸Ğ¼ÑƒÑ!
  
  status: "{emoji} ĞÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ <b>{hours}Ñ‡</b> Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° {urgency}"
  ending_soon: "â€” ÑƒÑĞ¿ĞµĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²ÑÑ‘!"
  ending_very_soon: "â€” Ğ¿Ğ¾Ñ€Ğ° Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚ÑŒ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ!"
  
  expired: |
    â° <b>Ğ’Ğ°Ñˆ Ğ¿Ñ€Ğ¾Ğ±Ğ½Ñ‹Ğ¹ Ğ¿ĞµÑ€Ğ¸Ğ¾Ğ´ Ğ·Ğ°ĞºĞ¾Ğ½Ñ‡Ğ¸Ğ»ÑÑ</b>
    
    ĞĞ°Ğ´ĞµĞµĞ¼ÑÑ, Ğ²Ğ°Ğ¼ Ğ¿Ğ¾Ğ½Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ°ÑÑŒ Ğ¸Ğ³Ñ€Ğ°!
    
    ĞŸÑ€Ğ¸Ğ¾Ğ±Ñ€ĞµÑ‚Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚ĞºÑ€Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğµ ÑÑ‚Ğ¾Ñ€Ğ¾Ğ½Ñ‹ Ğ²Ğ°ÑˆĞ¸Ñ… Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ğ¹.
  
  upgrade_now: "ğŸ’ ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿"
  
  reminder: |
    â° <b>ĞÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ Ğ²ÑĞµĞ³Ğ¾ {hours} Ñ‡Ğ°ÑĞ°!</b>
    
    Ğ’Ğ°Ñˆ Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ ÑĞºĞ¾Ñ€Ğ¾ Ğ·Ğ°ĞºĞ¾Ğ½Ñ‡Ğ¸Ñ‚ÑÑ.
    
    Ğ¥Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ Ğ¸Ğ³Ñ€Ğ°Ñ‚ÑŒ? Ğ¡ĞµĞ¹Ñ‡Ğ°Ñ ÑĞ°Ğ¼Ğ¾Ğµ Ğ²Ñ€ĞµĞ¼Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿!
```

#### ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ½Ğ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ñ

```python
# vechnost_bot/jobs/trial_reminder.py
"""Background job for trial expiration reminders."""

from telegram import Bot
from datetime import datetime, timedelta

from ..payments.trial_service import trial_service
from ..payments.repositories import TrialRepository
from ..payments.database import get_db
from ..i18n import get_text, Language


async def send_trial_reminders(bot: Bot) -> int:
    """
    Send reminders to users whose trials are expiring soon.
    
    Returns:
        Number of reminders sent
    """
    sent_count = 0
    
    async with get_db() as session:
        # Get trials expiring in next 2 hours that haven't been reminded
        expiring_trials = await TrialRepository.get_expiring_soon(
            session,
            hours_until_expiry=2,
        )
        
        for trial in expiring_trials:
            try:
                # Get user's language preference
                from ..storage import get_session
                user_session = await get_session(trial.telegram_user_id)
                language = user_session.language
                
                # Send reminder
                reminder_text = get_text("trial.reminder", language).format(
                    hours=trial.hours_remaining
                )
                
                await bot.send_message(
                    chat_id=trial.telegram_user_id,
                    text=reminder_text,
                    parse_mode="HTML",
                )
                
                # Mark as sent
                await TrialRepository.mark_reminder_sent(session, trial)
                sent_count += 1
                
            except Exception as e:
                logger.error(
                    f"Failed to send trial reminder to {trial.telegram_user_id}: {e}"
                )
    
    return sent_count


# Register as scheduled job in bot.py:
# application.job_queue.run_repeating(
#     send_trial_reminders,
#     interval=timedelta(minutes=30),
#     first=timedelta(minutes=5),
# )
```

---

## ğŸ® Ğ˜Ğ³Ñ€Ğ¾Ğ²Ñ‹Ğµ ÑƒĞ»ÑƒÑ‡ÑˆĞµĞ½Ğ¸Ñ Ğ¸ Ğ²Ğ¾Ğ²Ğ»ĞµÑ‡Ñ‘Ğ½Ğ½Ğ¾ÑÑ‚ÑŒ

### 1. Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ğ¹

```python
# vechnost_bot/achievements.py
"""Achievement system for gamification."""

from enum import Enum
from dataclasses import dataclass
from typing import Optional


class AchievementType(str, Enum):
    """Types of achievements."""
    FIRST_STEPS = "first_steps"        # Complete 10 questions
    EXPLORER = "explorer"               # Try all themes
    DEEP_DIVER = "deep_diver"          # Complete level 3 of any theme
    PASSIONATE = "passionate"           # Complete Sex theme
    PROVOCATEUR = "provocateur"         # Complete Provocation theme
    POLYGLOT = "polyglot"              # Use all 3 languages
    DAILY_PLAYER = "daily_player"      # Play 7 days in a row
    VOICE_USER = "voice_user"          # Send 10 voice messages
    COUPLE_GOALS = "couple_goals"      # Complete For Couples theme


@dataclass
class Achievement:
    """Achievement definition."""
    type: AchievementType
    name: dict[str, str]  # Localized names
    description: dict[str, str]  # Localized descriptions
    emoji: str
    points: int
    requirement: int  # Required count to unlock


ACHIEVEMENTS = {
    AchievementType.FIRST_STEPS: Achievement(
        type=AchievementType.FIRST_STEPS,
        name={"ru": "ĞŸĞµÑ€Ğ²Ñ‹Ğµ ÑˆĞ°Ğ³Ğ¸", "en": "First Steps", "cs": "PrvnÃ­ kroky"},
        description={
            "ru": "ĞÑ‚Ğ²ĞµÑ‚ÑŒ Ğ½Ğ° 10 Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²",
            "en": "Answer 10 questions",
            "cs": "OdpovÄ›z na 10 otÃ¡zek",
        },
        emoji="ğŸ¯",
        points=10,
        requirement=10,
    ),
    AchievementType.EXPLORER: Achievement(
        type=AchievementType.EXPLORER,
        name={"ru": "Ğ˜ÑÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ", "en": "Explorer", "cs": "PrÅ¯zkumnÃ­k"},
        description={
            "ru": "ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹ Ğ²ÑĞµ 4 Ñ‚ĞµĞ¼Ñ‹",
            "en": "Try all 4 themes",
            "cs": "VyzkouÅ¡ej vÅ¡echny 4 tÃ©mata",
        },
        emoji="ğŸŒŸ",
        points=25,
        requirement=4,
    ),
    # ... more achievements
}


class AchievementService:
    """Service for tracking and awarding achievements."""

    async def check_and_award(
        self,
        telegram_user_id: int,
        action: str,
        **context
    ) -> Optional[Achievement]:
        """
        Check if user earned an achievement and award it.
        
        Returns:
            Achievement if newly awarded, None otherwise
        """
        # Implementation...
        pass

    async def get_user_achievements(
        self,
        telegram_user_id: int
    ) -> list[Achievement]:
        """Get list of user's earned achievements."""
        pass
```

### 2. Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ¾Ğ²Ñ‹Ğµ ÑĞµÑÑĞ¸Ğ¸

```python
# vechnost_bot/group_sessions.py
"""Group game session management."""

from dataclasses import dataclass
from typing import Optional
import secrets


@dataclass
class GroupSession:
    """Group game session."""
    session_id: str
    host_user_id: int
    participants: list[int]
    theme: str
    level: int
    current_question_idx: int
    created_at: datetime
    
    @property
    def invite_link(self) -> str:
        """Generate invite deep link."""
        return f"https://t.me/VechnostBot?start=join_{self.session_id}"


class GroupSessionService:
    """Service for managing group sessions."""

    async def create_session(
        self,
        host_user_id: int,
        theme: str,
        level: int,
    ) -> GroupSession:
        """Create a new group session."""
        session_id = secrets.token_urlsafe(8)
        
        session = GroupSession(
            session_id=session_id,
            host_user_id=host_user_id,
            participants=[host_user_id],
            theme=theme,
            level=level,
            current_question_idx=0,
            created_at=datetime.utcnow(),
        )
        
        # Store in Redis with 2 hour TTL
        await self._store_session(session)
        
        return session

    async def join_session(
        self,
        session_id: str,
        user_id: int,
    ) -> Optional[GroupSession]:
        """Join an existing session."""
        session = await self._get_session(session_id)
        
        if not session:
            return None
        
        if user_id not in session.participants:
            session.participants.append(user_id)
            await self._store_session(session)
        
        return session

    async def sync_question(
        self,
        session_id: str,
        question_idx: int,
    ) -> None:
        """Sync question index for all participants."""
        session = await self._get_session(session_id)
        if session:
            session.current_question_idx = question_idx
            await self._store_session(session)
            
            # Notify all participants
            for user_id in session.participants:
                await self._notify_question_change(user_id, question_idx)
```

### 3. Ğ•Ğ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ñ‹Ğ¹ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ

```python
# vechnost_bot/daily_question.py
"""Daily question feature."""

import random
from datetime import date


class DailyQuestionService:
    """Service for daily question feature."""

    async def get_daily_question(
        self,
        language: Language,
    ) -> tuple[str, str, int]:
        """
        Get today's daily question.
        
        Returns:
            (question_text, theme, level)
        """
        # Use date as seed for consistent daily question
        today = date.today()
        random.seed(today.toordinal())
        
        # Select random theme and question
        themes = list(GAME_DATA.themes.keys())
        theme = random.choice(themes)
        
        level = random.randint(1, 3)
        questions = GAME_DATA.get_content(theme, level, ContentType.QUESTIONS)
        
        if not questions:
            level = None
            questions = GAME_DATA.get_content(theme, None, ContentType.QUESTIONS)
        
        question = random.choice(questions)
        
        return question, theme.value, level

    async def send_daily_question(
        self,
        bot: Bot,
        user_ids: list[int],
    ) -> int:
        """
        Send daily question to subscribed users.
        
        Returns:
            Number of messages sent
        """
        sent = 0
        
        for user_id in user_ids:
            try:
                session = await get_session(user_id)
                question, theme, level = await self.get_daily_question(
                    session.language
                )
                
                text = get_text("daily.question", session.language).format(
                    question=question,
                    theme=theme,
                )
                
                await bot.send_message(
                    chat_id=user_id,
                    text=text,
                    parse_mode="HTML",
                )
                sent += 1
                
            except Exception as e:
                logger.error(f"Failed to send daily question to {user_id}: {e}")
        
        return sent
```

---

## ğŸ’° Ğ¡Ñ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ñ Ğ¼Ğ¾Ğ½ĞµÑ‚Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸

### Ğ¢ĞµĞºÑƒÑ‰Ğ°Ñ Ğ¼Ğ¾Ğ´ĞµĞ»ÑŒ

Ğ¡ĞµĞ¹Ñ‡Ğ°Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ:
- Tribute API Ğ´Ğ»Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ĞµĞ¹
- Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° ÑĞµÑ€Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ‚Ğ¾Ğ² Ğ´Ğ»Ñ Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
- Ğ•Ğ´Ğ¸Ğ½Ğ¾Ñ€Ğ°Ğ·Ğ¾Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞ° lifetime Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°

### Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒĞµĞ¼Ğ°Ñ Ñ†ĞµĞ½Ğ¾Ğ²Ğ°Ñ Ğ¿Ğ¾Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ°

#### ĞœĞ¾Ğ´ĞµĞ»Ğ¸ Ğ¼Ğ¾Ğ½ĞµÑ‚Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PRICING TIERS                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  ğŸ†“ FREE TRIAL (24 hours)                                       â”‚
â”‚     â€¢ Full access to all features                               â”‚
â”‚     â€¢ No payment required                                       â”‚
â”‚     â€¢ Automatic expiration                                      â”‚
â”‚                                                                 â”‚
â”‚  â­ BASIC ($4.99/month or 250 Stars)                           â”‚
â”‚     â€¢ All themes and questions                                  â”‚
â”‚     â€¢ Card rendering                                            â”‚
â”‚     â€¢ Multi-language support                                    â”‚
â”‚                                                                 â”‚
â”‚  ğŸ’ PREMIUM ($9.99/month or 500 Stars)                          â”‚
â”‚     â€¢ Everything in Basic                                       â”‚
â”‚     â€¢ AI voice transcription                                    â”‚
â”‚     â€¢ AI-generated custom questions                             â”‚
â”‚     â€¢ Voice narration of questions                              â”‚
â”‚     â€¢ Priority support                                          â”‚
â”‚                                                                 â”‚
â”‚  ğŸ‘‘ LIFETIME ($29.99 or 1500 Stars)                            â”‚
â”‚     â€¢ All Premium features forever                              â”‚
â”‚     â€¢ Early access to new features                              â”‚
â”‚     â€¢ Exclusive themes                                          â”‚
â”‚                                                                 â”‚
â”‚  ğŸ GIFT CERTIFICATES ($19.99+)                                â”‚
â”‚     â€¢ 1 month / 3 months / Lifetime                            â”‚
â”‚     â€¢ Shareable QR codes                                        â”‚
â”‚     â€¢ Perfect for couples as gift                               â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Telegram Stars Integration

Telegram Stars â€” Ğ½Ğ¾Ğ²Ğ°Ñ Ğ²Ğ°Ğ»ÑÑ‚Ğ° Ğ´Ğ»Ñ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹ Ğ² Ğ±Ğ¾Ñ‚Ğ°Ñ…. ĞŸÑ€ĞµĞ¸Ğ¼ÑƒÑ‰ĞµÑÑ‚Ğ²Ğ°:
- ĞĞ°Ñ‚Ğ¸Ğ²Ğ½Ğ°Ñ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ğ±ĞµĞ· Ğ²Ğ½ĞµÑˆĞ½Ğ¸Ñ… Ğ¿Ğ»Ğ°Ñ‚Ñ‘Ğ¶Ğ½Ñ‹Ñ… ÑĞ¸ÑÑ‚ĞµĞ¼
- ĞĞ¸Ğ·ĞºĞ°Ñ ĞºĞ¾Ğ¼Ğ¸ÑÑĞ¸Ñ (15-30% vs 30% Ñƒ App Store)
- ĞœĞ³Ğ½Ğ¾Ğ²ĞµĞ½Ğ½Ñ‹Ğµ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ¸ Ğ±ĞµĞ· Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸
- ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑĞºĞ¸ Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ¿Ñ€Ğ¾Ğ´Ğ»ĞµĞ½Ğ¸ĞµĞ¼

```python
# vechnost_bot/payments/stars_handler.py
"""Telegram Stars payment handling."""

from telegram import LabeledPrice, Update
from telegram.ext import ContextTypes


PRODUCTS = {
    "basic_monthly": {
        "title": "Vechnost Basic",
        "description": "Monthly access to all themes and questions",
        "prices": [LabeledPrice("Monthly subscription", 25000)],  # 250 Stars
        "subscription_period": 2592000,  # 30 days in seconds
    },
    "premium_monthly": {
        "title": "Vechnost Premium",
        "description": "Premium with AI features",
        "prices": [LabeledPrice("Monthly subscription", 50000)],  # 500 Stars
        "subscription_period": 2592000,
    },
    "lifetime": {
        "title": "Vechnost Lifetime",
        "description": "Lifetime access to all features",
        "prices": [LabeledPrice("One-time purchase", 150000)],  # 1500 Stars
        "subscription_period": None,  # One-time
    },
}


async def send_invoice(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    product_id: str,
) -> None:
    """Send payment invoice using Telegram Stars."""
    product = PRODUCTS.get(product_id)
    if not product:
        return

    await context.bot.send_invoice(
        chat_id=update.effective_chat.id,
        title=product["title"],
        description=product["description"],
        payload=f"vechnost_{product_id}",
        currency="XTR",  # Telegram Stars
        prices=product["prices"],
        subscription_period=product.get("subscription_period"),
    )


async def handle_successful_payment(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
) -> None:
    """Handle successful Star payment."""
    payment = update.message.successful_payment
    
    user_id = update.effective_user.id
    payload = payment.invoice_payload
    
    # Grant access based on payload
    if "lifetime" in payload:
        await grant_lifetime_access(user_id)
    elif "premium" in payload:
        await grant_premium_subscription(
            user_id,
            expiration=payment.subscription_expiration_date,
        )
    elif "basic" in payload:
        await grant_basic_subscription(
            user_id,
            expiration=payment.subscription_expiration_date,
        )
    
    # Send confirmation
    await update.message.reply_text(
        get_text("payment.success", session.language)
    )
```

### ĞĞ½Ğ°Ğ»Ğ¸Ğ· Ñ€Ñ‹Ğ½ĞºĞ° Ğ¸ ĞºĞ¾Ğ½ĞºÑƒÑ€ĞµĞ½Ñ‚Ğ¾Ğ²

| ĞŸÑ€Ğ¾Ğ´ÑƒĞºÑ‚ | ĞœĞ¾Ğ´ĞµĞ»ÑŒ | Ğ¦ĞµĞ½Ğ° | ĞÑĞ¾Ğ±ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸ |
|---------|--------|------|-------------|
| Vertellis | Ğ¤Ğ¸Ğ·Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ ĞºĞ°Ñ€Ñ‚Ñ‹ | $25-45 | ĞŸÑ€ĞµĞ¼Ğ¸ÑƒĞ¼ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾, Ğ¿Ğ¾Ğ´Ğ°Ñ€Ğ¾Ñ‡Ğ½Ğ°Ñ ÑƒĞ¿Ğ°ĞºĞ¾Ğ²ĞºĞ° |
| Couple Game App | Freemium | $4.99/Ğ¼ĞµÑ | ĞœĞ½Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ½Ñ‚ĞµĞ½Ñ‚Ğ°, Ñ€ĞµĞºĞ»Ğ°Ğ¼Ğ° Ğ² Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ğ¾Ğ¹ Ğ²ĞµÑ€ÑĞ¸Ğ¸ |
| Love Nudge | ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑĞºĞ° | $9.99/Ğ¼ĞµÑ | AI Ñ€ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ğ¸, Ğ½Ğ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ñ |
| **Vechnost** | Stars/Subscription | $4.99-29.99 | Telegram Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ, AI, Ğ³Ğ¾Ğ»Ğ¾Ñ |

### ĞŸÑ€Ğ¾Ğ³Ğ½Ğ¾Ğ· Ğ´Ğ¾Ñ…Ğ¾Ğ´Ğ¾Ğ²

ĞŸÑ€Ğ¸ **1000 Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹**:

| Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ | ĞšĞ¾Ğ½Ğ²ĞµÑ€ÑĞ¸Ñ | Ğ¡Ñ€ĞµĞ´Ğ½Ğ¸Ğ¹ Ñ‡ĞµĞº | Ğ”Ğ¾Ñ…Ğ¾Ğ´/Ğ¼ĞµÑ |
|----------|-----------|-------------|-----------|
| ĞŸĞµÑÑĞ¸Ğ¼Ğ¸ÑÑ‚Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ | 3% | $5 | $150 |
| Ğ ĞµĞ°Ğ»Ğ¸ÑÑ‚Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ | 7% | $8 | $560 |
| ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸ÑÑ‚Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ | 15% | $12 | $1,800 |

**Ğ Ğ°ÑÑ…Ğ¾Ğ´Ñ‹:**
- Ğ¥Ğ¾ÑÑ‚Ğ¸Ğ½Ğ³ (Railway/Render): ~$20/Ğ¼ĞµÑ
- Redis: ~$10/Ğ¼ĞµÑ
- OpenAI API: ~$30-50/Ğ¼ĞµÑ (Ğ¿Ñ€Ğ¸ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğ¼ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸ AI)
- Tribute ĞºĞ¾Ğ¼Ğ¸ÑÑĞ¸Ñ: 5% Ğ¾Ñ‚ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¹

**Ğ¢Ğ¾Ñ‡ĞºĞ° Ğ±ĞµĞ·ÑƒĞ±Ñ‹Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚Ğ¸:** ~60 Ğ¿Ğ»Ğ°Ñ‚ÑÑ‰Ğ¸Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹

---

## ğŸ“‹ Ğ¢ĞµÑ…Ğ½Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¿Ğ»Ğ°Ğ½ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸

### Ğ¤Ğ°Ğ·Ğ° 1: AI Integration (2-3 Ğ½ĞµĞ´ĞµĞ»Ğ¸)

```
ĞĞµĞ´ĞµĞ»Ñ 1:
â”œâ”€â”€ [x] ĞĞ½Ğ°Ğ»Ğ¸Ğ· ĞºĞ¾Ğ´Ğ¾Ğ²Ğ¾Ğ¹ Ğ±Ğ°Ğ·Ñ‹
â”œâ”€â”€ [ ] Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ OpenAI SDK Ğ² Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸
â”œâ”€â”€ [ ] Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ WhisperService
â”œâ”€â”€ [ ] Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ³Ğ¾Ğ»Ğ¾ÑĞ¾Ğ²Ñ‹Ñ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹
â””â”€â”€ [ ] ĞĞ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ unit Ñ‚ĞµÑÑ‚Ñ‹

ĞĞµĞ´ĞµĞ»Ñ 2:
â”œâ”€â”€ [ ] Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ QuestionGenerator
â”œâ”€â”€ [ ] Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ TTSService
â”œâ”€â”€ [ ] Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´Ñ‹ Ğ´Ğ»Ñ AI Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¹
â”œâ”€â”€ [ ] Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğµ Ñ‚ĞµÑÑ‚Ñ‹
â””â”€â”€ [ ] Ğ”Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ

ĞĞµĞ´ĞµĞ»Ñ 3:
â”œâ”€â”€ [ ] A/B Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
â”œâ”€â”€ [ ] ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ğ¸ Ğ¼ĞµÑ‚Ñ€Ğ¸ĞºĞ¸
â”œâ”€â”€ [ ] ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸
â””â”€â”€ [ ] Ğ”ĞµĞ¿Ğ»Ğ¾Ğ¹ Ğ² Ğ¿Ñ€Ğ¾Ğ´Ğ°ĞºÑˆĞ½
```

### Ğ¤Ğ°Ğ·Ğ° 2: 24h Trial & Graphics (2 Ğ½ĞµĞ´ĞµĞ»Ğ¸)

```
ĞĞµĞ´ĞµĞ»Ñ 4:
â”œâ”€â”€ [ ] Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¼Ğ¾Ğ´ĞµĞ»ÑŒ TrialAccess
â”œâ”€â”€ [ ] ĞœĞ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ñ Alembic
â”œâ”€â”€ [ ] Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ TrialService
â”œâ”€â”€ [ ] ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ middleware Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ñ‚Ñ€Ğ¸Ğ°Ğ»Ğ°
â””â”€â”€ [ ] Scheduled job Ğ´Ğ»Ñ Ğ½Ğ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ğ¹

ĞĞµĞ´ĞµĞ»Ñ 5:
â”œâ”€â”€ [ ] Ğ£Ğ»ÑƒÑ‡ÑˆĞ¸Ñ‚ÑŒ renderer
â”œâ”€â”€ [ ] Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ³Ñ€Ğ°Ğ´Ğ¸ĞµĞ½Ñ‚Ñ‹ Ğ¸ Ğ´ĞµĞºĞ¾Ñ€Ğ°Ñ†Ğ¸Ğ¸
â”œâ”€â”€ [ ] Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ°Ğ´Ğ°Ğ¿Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚
â”œâ”€â”€ [ ] Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¾Ñ‚Ğ¸Ğ¿ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸
â””â”€â”€ [ ] Ğ¢ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ° Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ°Ñ…
```

### Ğ¤Ğ°Ğ·Ğ° 3: Stars Payments (1-2 Ğ½ĞµĞ´ĞµĞ»Ğ¸)

```
ĞĞµĞ´ĞµĞ»Ñ 6-7:
â”œâ”€â”€ [ ] Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Telegram Stars API
â”œâ”€â”€ [ ] Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºĞ¸
â”œâ”€â”€ [ ] ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ UI Ğ´Ğ»Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ¿Ğ»Ğ°Ğ½Ğ°
â”œâ”€â”€ [ ] Ğ¢ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ĞµĞ¹
â””â”€â”€ [ ] ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° ĞºĞ¾Ğ½Ğ²ĞµÑ€ÑĞ¸Ğ¹
```

### Ğ¤Ğ°Ğ·Ğ° 4: Gamification (2-3 Ğ½ĞµĞ´ĞµĞ»Ğ¸)

```
ĞĞµĞ´ĞµĞ»Ñ 8-10:
â”œâ”€â”€ [ ] Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ğ¹
â”œâ”€â”€ [ ] Ğ•Ğ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ñ‹Ğ¹ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ
â”œâ”€â”€ [ ] Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ¾Ğ²Ñ‹Ğµ ÑĞµÑÑĞ¸Ğ¸ (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾)
â”œâ”€â”€ [ ] Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ¸ Ğ¿Ñ€Ğ¾Ğ³Ñ€ĞµÑÑ
â””â”€â”€ [ ] Ğ¤Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
```

---

## ğŸ“ ĞŸÑ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ

### A. ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ

```env
# .env additions

# OpenAI Configuration
OPENAI_API_KEY=sk-xxx
ENABLE_VOICE_TRANSCRIPTION=true
ENABLE_TTS=true
ENABLE_AI_QUESTIONS=true

# Trial Configuration
TRIAL_DURATION_HOURS=24
TRIAL_REMINDER_HOURS=2

# Telegram Stars
ENABLE_STARS_PAYMENTS=true

# Feature Flags
ENABLE_ACHIEVEMENTS=false
ENABLE_GROUP_SESSIONS=false
ENABLE_DAILY_QUESTION=true
```

### B. ĞœĞ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ‘Ğ”

```python
# alembic/versions/xxx_add_trial_access.py
"""Add trial_access table

Revision ID: xxx
"""

from alembic import op
import sqlalchemy as sa


def upgrade() -> None:
    op.create_table(
        'trial_access',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('telegram_user_id', sa.BigInteger(), nullable=False),
        sa.Column('started_at', sa.DateTime(), nullable=False),
        sa.Column('expires_at', sa.DateTime(), nullable=False),
        sa.Column('converted_to_paid', sa.Boolean(), default=False),
        sa.Column('reminder_sent', sa.Boolean(), default=False),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('telegram_user_id'),
    )
    op.create_index('idx_trial_telegram_user', 'trial_access', ['telegram_user_id'])
    op.create_index('idx_trial_expires', 'trial_access', ['expires_at'])


def downgrade() -> None:
    op.drop_index('idx_trial_expires', 'trial_access')
    op.drop_index('idx_trial_telegram_user', 'trial_access')
    op.drop_table('trial_access')
```

### C. Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸

```toml
# pyproject.toml additions

[project]
dependencies = [
    # ... existing dependencies ...
    
    # AI Integration
    "openai>=1.68.0",
    
    # Enhanced Graphics
    "pillow>=10.0.0",
    
    # Background Jobs
    "apscheduler>=3.10.0",
]
```

### D. ĞœĞµÑ‚Ñ€Ğ¸ĞºĞ¸ ÑƒÑĞ¿ĞµÑ…Ğ°

| ĞœĞµÑ‚Ñ€Ğ¸ĞºĞ° | Ğ¢ĞµĞºÑƒÑ‰ĞµĞµ | Ğ¦ĞµĞ»ÑŒ (Q2 2026) |
|---------|---------|----------------|
| DAU | ? | 500+ |
| ĞšĞ¾Ğ½Ğ²ĞµÑ€ÑĞ¸Ñ trial â†’ paid | N/A | 10%+ |
| Retention D7 | ? | 40%+ |
| Ğ¡Ñ€ĞµĞ´Ğ½Ğ¸Ğ¹ Ñ‡ĞµĞº | $0 | $8+ |
| NPS | ? | 50+ |

---

## ğŸ¯ Ğ’Ñ‹Ğ²Ğ¾Ğ´Ñ‹

ĞŸÑ€Ğ¾ĞµĞºÑ‚ Vechnost Ğ¸Ğ¼ĞµĞµÑ‚ **Ğ¾Ñ‚Ğ»Ğ¸Ñ‡Ğ½ÑƒÑ Ñ‚ĞµÑ…Ğ½Ğ¸Ñ‡ĞµÑĞºÑƒÑ Ğ±Ğ°Ğ·Ñƒ** Ğ¸ Ğ³Ğ¾Ñ‚Ğ¾Ğ² Ğº Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±Ğ½Ğ¾Ğ¼Ñƒ Ñ€Ğ°Ğ·Ğ²Ğ¸Ñ‚Ğ¸Ñ. ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ñ€ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ğ¸:

### ĞĞµĞ¼ĞµĞ´Ğ»ĞµĞ½Ğ½Ñ‹Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ (ÑÑ‚Ğ° Ğ½ĞµĞ´ĞµĞ»Ñ)
1. âœ… Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ OpenAI Whisper Ğ´Ğ»Ñ Ğ³Ğ¾Ğ»Ğ¾ÑĞ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ²Ğ²Ğ¾Ğ´Ğ°
2. âœ… Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ 24-Ñ‡Ğ°ÑĞ¾Ğ²Ğ¾Ğ¹ Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ñ‹Ğ¹ Ğ¿Ñ€Ğ¾Ğ±Ğ½Ñ‹Ğ¹ Ğ¿ĞµÑ€Ğ¸Ğ¾Ğ´
3. âœ… Ğ£Ğ»ÑƒÑ‡ÑˆĞ¸Ñ‚ÑŒ Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¾Ñ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞµĞº

### ĞšÑ€Ğ°Ñ‚ĞºĞ¾ÑÑ€Ğ¾Ñ‡Ğ½Ñ‹Ğµ Ñ†ĞµĞ»Ğ¸ (ÑÑ‚Ğ¾Ñ‚ Ğ¼ĞµÑÑÑ†)
4. â³ Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Telegram Stars Ğ´Ğ»Ñ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ĞµĞ¹
5. â³ Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¾Ğ² Ñ‡ĞµÑ€ĞµĞ· GPT
6. â³ Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑĞ¸ÑÑ‚ĞµĞ¼Ñƒ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ğ¹

### Ğ”Ğ¾Ğ»Ğ³Ğ¾ÑÑ€Ğ¾Ñ‡Ğ½Ñ‹Ğµ Ñ†ĞµĞ»Ğ¸ (ĞºĞ²Ğ°Ñ€Ñ‚Ğ°Ğ»)
7. ğŸ“… Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ¾Ğ²Ñ‹Ğµ Ğ¸Ğ³Ñ€Ğ¾Ğ²Ñ‹Ğµ ÑĞµÑÑĞ¸Ğ¸
8. ğŸ“… Ğ Ğ°ÑÑˆĞ¸Ñ€Ğ¸Ñ‚ÑŒ ÑĞ·Ñ‹ĞºĞ¾Ğ²ÑƒÑ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºÑƒ
9. ğŸ“… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Telegram Mini App

---

**ĞĞ²Ñ‚Ğ¾Ñ€:** AI Assistant (Claude)  
**Ğ”Ğ°Ñ‚Ğ°:** 3 Ñ„ĞµĞ²Ñ€Ğ°Ğ»Ñ 2026  
**Ğ’ĞµÑ€ÑĞ¸Ñ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°:** 1.0

---

> ğŸ’¡ *"Vechnost â€” Ğ½Ğµ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ¸Ğ³Ñ€Ğ°. Ğ­Ñ‚Ğ¾ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ³Ğ»ÑƒĞ±Ğ¾ĞºĞ¸Ñ… ÑĞ²ÑĞ·ĞµĞ¹ Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ»ÑĞ´ÑŒĞ¼Ğ¸."*
